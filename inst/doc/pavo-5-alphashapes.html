<!DOCTYPE html>

<html>

<head>

<meta charset="utf-8" />
<meta name="generator" content="pandoc" />
<meta http-equiv="X-UA-Compatible" content="IE=EDGE" />

<meta name="viewport" content="width=device-width, initial-scale=1" />

<meta name="author" content="Hugo Gruson" />

<meta name="date" content="2020-12-09" />

<title>Colour volume estimation</title>

<script>// Pandoc 2.9 adds attributes on both header and div. We remove the former (to
// be compatible with the behavior of Pandoc < 2.8).
document.addEventListener('DOMContentLoaded', function(e) {
  var hs = document.querySelectorAll("div.section[class*='level'] > :first-child");
  var i, h, a;
  for (i = 0; i < hs.length; i++) {
    h = hs[i];
    if (!/^h[1-6]$/i.test(h.tagName)) continue;  // it should be a header h1-h6
    a = h.attributes;
    while (a.length > 0) h.removeAttribute(a[0].name);
  }
});
</script>
<script>// Hide empty <a> tag within highlighted CodeBlock for screen reader accessibility (see https://github.com/jgm/pandoc/issues/6352#issuecomment-626106786) -->
// v0.0.1
// Written by JooYoung Seo (jooyoung@psu.edu) and Atsushi Yasumoto on June 1st, 2020.

document.addEventListener('DOMContentLoaded', function() {
  const codeList = document.getElementsByClassName("sourceCode");
  for (var i = 0; i < codeList.length; i++) {
    var linkList = codeList[i].getElementsByTagName('a');
    for (var j = 0; j < linkList.length; j++) {
      if (linkList[j].innerHTML === "") {
        linkList[j].setAttribute('aria-hidden', 'true');
      }
    }
  }
});
</script>

<style type="text/css">
  code{white-space: pre-wrap;}
  span.smallcaps{font-variant: small-caps;}
  span.underline{text-decoration: underline;}
  div.column{display: inline-block; vertical-align: top; width: 50%;}
  div.hanging-indent{margin-left: 1.5em; text-indent: -1.5em;}
  ul.task-list{list-style: none;}
      pre > code.sourceCode { white-space: pre; position: relative; }
      pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
      pre > code.sourceCode > span:empty { height: 1.2em; }
      code.sourceCode > span { color: inherit; text-decoration: inherit; }
      div.sourceCode { margin: 1em 0; }
      pre.sourceCode { margin: 0; }
      @media screen {
      div.sourceCode { overflow: auto; }
      }
      @media print {
      pre > code.sourceCode { white-space: pre-wrap; }
      pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
      }
      pre.numberSource code
        { counter-reset: source-line 0; }
      pre.numberSource code > span
        { position: relative; left: -4em; counter-increment: source-line; }
      pre.numberSource code > span > a:first-child::before
        { content: counter(source-line);
          position: relative; left: -1em; text-align: right; vertical-align: baseline;
          border: none; display: inline-block;
          -webkit-touch-callout: none; -webkit-user-select: none;
          -khtml-user-select: none; -moz-user-select: none;
          -ms-user-select: none; user-select: none;
          padding: 0 4px; width: 4em;
          color: #aaaaaa;
        }
      pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
      div.sourceCode
        {   }
      @media screen {
      pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
      }
      code span.al { color: #ff0000; font-weight: bold; } /* Alert */
      code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
      code span.at { color: #7d9029; } /* Attribute */
      code span.bn { color: #40a070; } /* BaseN */
      code span.bu { } /* BuiltIn */
      code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
      code span.ch { color: #4070a0; } /* Char */
      code span.cn { color: #880000; } /* Constant */
      code span.co { color: #60a0b0; font-style: italic; } /* Comment */
      code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
      code span.do { color: #ba2121; font-style: italic; } /* Documentation */
      code span.dt { color: #902000; } /* DataType */
      code span.dv { color: #40a070; } /* DecVal */
      code span.er { color: #ff0000; font-weight: bold; } /* Error */
      code span.ex { } /* Extension */
      code span.fl { color: #40a070; } /* Float */
      code span.fu { color: #06287e; } /* Function */
      code span.im { } /* Import */
      code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
      code span.kw { color: #007020; font-weight: bold; } /* Keyword */
      code span.op { color: #666666; } /* Operator */
      code span.ot { color: #007020; } /* Other */
      code span.pp { color: #bc7a00; } /* Preprocessor */
      code span.sc { color: #4070a0; } /* SpecialChar */
      code span.ss { color: #bb6688; } /* SpecialString */
      code span.st { color: #4070a0; } /* String */
      code span.va { color: #19177c; } /* Variable */
      code span.vs { color: #4070a0; } /* VerbatimString */
      code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */
    </style>


<style type="text/css">code{white-space: pre;}</style>
<style type="text/css" data-origin="pandoc">
pre > code.sourceCode { white-space: pre; position: relative; }
pre > code.sourceCode > span { display: inline-block; line-height: 1.25; }
pre > code.sourceCode > span:empty { height: 1.2em; }
code.sourceCode > span { color: inherit; text-decoration: inherit; }
div.sourceCode { margin: 1em 0; }
pre.sourceCode { margin: 0; }
@media screen {
div.sourceCode { overflow: auto; }
}
@media print {
pre > code.sourceCode { white-space: pre-wrap; }
pre > code.sourceCode > span { text-indent: -5em; padding-left: 5em; }
}
pre.numberSource code
  { counter-reset: source-line 0; }
pre.numberSource code > span
  { position: relative; left: -4em; counter-increment: source-line; }
pre.numberSource code > span > a:first-child::before
  { content: counter(source-line);
    position: relative; left: -1em; text-align: right; vertical-align: baseline;
    border: none; display: inline-block;
    -webkit-touch-callout: none; -webkit-user-select: none;
    -khtml-user-select: none; -moz-user-select: none;
    -ms-user-select: none; user-select: none;
    padding: 0 4px; width: 4em;
    color: #aaaaaa;
  }
pre.numberSource { margin-left: 3em; border-left: 1px solid #aaaaaa;  padding-left: 4px; }
div.sourceCode
  {   }
@media screen {
pre > code.sourceCode > span > a:first-child::before { text-decoration: underline; }
}
code span.al { color: #ff0000; font-weight: bold; } /* Alert */
code span.an { color: #60a0b0; font-weight: bold; font-style: italic; } /* Annotation */
code span.at { color: #7d9029; } /* Attribute */
code span.bn { color: #40a070; } /* BaseN */
code span.bu { } /* BuiltIn */
code span.cf { color: #007020; font-weight: bold; } /* ControlFlow */
code span.ch { color: #4070a0; } /* Char */
code span.cn { color: #880000; } /* Constant */
code span.co { color: #60a0b0; font-style: italic; } /* Comment */
code span.cv { color: #60a0b0; font-weight: bold; font-style: italic; } /* CommentVar */
code span.do { color: #ba2121; font-style: italic; } /* Documentation */
code span.dt { color: #902000; } /* DataType */
code span.dv { color: #40a070; } /* DecVal */
code span.er { color: #ff0000; font-weight: bold; } /* Error */
code span.ex { } /* Extension */
code span.fl { color: #40a070; } /* Float */
code span.fu { color: #06287e; } /* Function */
code span.im { } /* Import */
code span.in { color: #60a0b0; font-weight: bold; font-style: italic; } /* Information */
code span.kw { color: #007020; font-weight: bold; } /* Keyword */
code span.op { color: #666666; } /* Operator */
code span.ot { color: #007020; } /* Other */
code span.pp { color: #bc7a00; } /* Preprocessor */
code span.sc { color: #4070a0; } /* SpecialChar */
code span.ss { color: #bb6688; } /* SpecialString */
code span.st { color: #4070a0; } /* String */
code span.va { color: #19177c; } /* Variable */
code span.vs { color: #4070a0; } /* VerbatimString */
code span.wa { color: #60a0b0; font-weight: bold; font-style: italic; } /* Warning */

</style>
<script>
// apply pandoc div.sourceCode style to pre.sourceCode instead
(function() {
  var sheets = document.styleSheets;
  for (var i = 0; i < sheets.length; i++) {
    if (sheets[i].ownerNode.dataset["origin"] !== "pandoc") continue;
    try { var rules = sheets[i].cssRules; } catch (e) { continue; }
    for (var j = 0; j < rules.length; j++) {
      var rule = rules[j];
      // check if there is a div.sourceCode rule
      if (rule.type !== rule.STYLE_RULE || rule.selectorText !== "div.sourceCode") continue;
      var style = rule.style.cssText;
      // check if color or background-color is set
      if (rule.style.color === '' && rule.style.backgroundColor === '') continue;
      // replace div.sourceCode by a pre.sourceCode rule
      sheets[i].deleteRule(j);
      sheets[i].insertRule('pre.sourceCode{' + style + '}', j);
    }
  }
})();
</script>



<style type="text/css">body {
background-color: #fff;
margin: 1em auto;
max-width: 700px;
overflow: visible;
padding-left: 2em;
padding-right: 2em;
font-family: "Open Sans", "Helvetica Neue", Helvetica, Arial, sans-serif;
font-size: 14px;
line-height: 1.35;
}
#TOC {
clear: both;
margin: 0 0 10px 10px;
padding: 4px;
width: 400px;
border: 1px solid #CCCCCC;
border-radius: 5px;
background-color: #f6f6f6;
font-size: 13px;
line-height: 1.3;
}
#TOC .toctitle {
font-weight: bold;
font-size: 15px;
margin-left: 5px;
}
#TOC ul {
padding-left: 40px;
margin-left: -1.5em;
margin-top: 5px;
margin-bottom: 5px;
}
#TOC ul ul {
margin-left: -2em;
}
#TOC li {
line-height: 16px;
}
table {
margin: 1em auto;
border-width: 1px;
border-color: #DDDDDD;
border-style: outset;
border-collapse: collapse;
}
table th {
border-width: 2px;
padding: 5px;
border-style: inset;
}
table td {
border-width: 1px;
border-style: inset;
line-height: 18px;
padding: 5px 5px;
}
table, table th, table td {
border-left-style: none;
border-right-style: none;
}
table thead, table tr.even {
background-color: #f7f7f7;
}
p {
margin: 0.5em 0;
}
blockquote {
background-color: #f6f6f6;
padding: 0.25em 0.75em;
}
hr {
border-style: solid;
border: none;
border-top: 1px solid #777;
margin: 28px 0;
}
dl {
margin-left: 0;
}
dl dd {
margin-bottom: 13px;
margin-left: 13px;
}
dl dt {
font-weight: bold;
}
ul {
margin-top: 0;
}
ul li {
list-style: circle outside;
}
ul ul {
margin-bottom: 0;
}
pre, code {
background-color: #f7f7f7;
border-radius: 3px;
color: #333;
white-space: pre-wrap; 
}
pre {
border-radius: 3px;
margin: 5px 0px 10px 0px;
padding: 10px;
}
pre:not([class]) {
background-color: #f7f7f7;
}
code {
font-family: Consolas, Monaco, 'Courier New', monospace;
font-size: 85%;
}
p > code, li > code {
padding: 2px 0px;
}
div.figure {
text-align: center;
}
img {
background-color: #FFFFFF;
padding: 2px;
border: 1px solid #DDDDDD;
border-radius: 3px;
border: 1px solid #CCCCCC;
margin: 0 5px;
}
h1 {
margin-top: 0;
font-size: 35px;
line-height: 40px;
}
h2 {
border-bottom: 4px solid #f7f7f7;
padding-top: 10px;
padding-bottom: 2px;
font-size: 145%;
}
h3 {
border-bottom: 2px solid #f7f7f7;
padding-top: 10px;
font-size: 120%;
}
h4 {
border-bottom: 1px solid #f7f7f7;
margin-left: 8px;
font-size: 105%;
}
h5, h6 {
border-bottom: 1px solid #ccc;
font-size: 105%;
}
a {
color: #0033dd;
text-decoration: none;
}
a:hover {
color: #6666ff; }
a:visited {
color: #800080; }
a:visited:hover {
color: #BB00BB; }
a[href^="http:"] {
text-decoration: underline; }
a[href^="https:"] {
text-decoration: underline; }

code > span.kw { color: #555; font-weight: bold; } 
code > span.dt { color: #902000; } 
code > span.dv { color: #40a070; } 
code > span.bn { color: #d14; } 
code > span.fl { color: #d14; } 
code > span.ch { color: #d14; } 
code > span.st { color: #d14; } 
code > span.co { color: #888888; font-style: italic; } 
code > span.ot { color: #007020; } 
code > span.al { color: #ff0000; font-weight: bold; } 
code > span.fu { color: #900; font-weight: bold; } 
code > span.er { color: #a61717; background-color: #e3d2d2; } 
</style>




</head>

<body>




<h1 class="title toc-ignore">Colour volume estimation</h1>
<h4 class="author">Hugo Gruson</h4>
<h4 class="date">2020-12-09</h4>



<p>Traditionally, colour volume or “colourfulness” of an object has been measured by computing the volume of the convex hull containing the data points, as described in <span class="citation">(Stoddard and Prum <a href="#ref-Stoddard2008" role="doc-biblioref">2008</a>)</span></p>
<p><span class="math inline">\(\alpha\)</span>-shapes are a new tool available in <code>pavo</code> to estimate colour volumes, while allowing the presence of voids and pockets, which may lead to a more accurate measurement of “colourfulness” than convex hulls. For more information on the theoretical background, please report to the related article <span class="citation">(Gruson <a href="#ref-Gruson2020" role="doc-biblioref">2020</a>)</span></p>
<div id="alpha-shapes-in-chromaticity-diagrams" class="section level1">
<h1><span class="math inline">\(\alpha\)</span>-shapes in chromaticity diagrams</h1>
<p>You can plot the colour volume using <span class="math inline">\(\alpha\)</span>-shape with the <code>vol()</code> function (for non-interactive plots, <code>tcsvol()</code> otherwise) by specifying <code>type = &quot;alpha&quot;</code>. By default, this will use the <span class="math inline">\(\alpha^*\)</span> value defined in <span class="citation">Gruson (<a href="#ref-Gruson2020" role="doc-biblioref">2020</a>)</span>.</p>
<div class="sourceCode" id="cb1"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb1-1"><a href="#cb1-1"></a><span class="kw">library</span>(pavo)</span>
<span id="cb1-2"><a href="#cb1-2"></a><span class="kw">data</span>(flowers)</span>
<span id="cb1-3"><a href="#cb1-3"></a>vis_flowers &lt;-<span class="st"> </span><span class="kw">vismodel</span>(flowers, <span class="dt">visual =</span> <span class="st">&quot;avg.uv&quot;</span>)</span>
<span id="cb1-4"><a href="#cb1-4"></a>tcs_flowers &lt;-<span class="st"> </span><span class="kw">colspace</span>(vis_flowers)</span>
<span id="cb1-5"><a href="#cb1-5"></a><span class="kw">plot</span>(tcs_flowers)</span></code></pre></div>
<p><img src="data:image/png;base64,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" style="display: block; margin: auto;" /></p>
<div class="sourceCode" id="cb2"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb2-1"><a href="#cb2-1"></a><span class="kw">vol</span>(tcs_flowers, <span class="dt">type =</span> <span class="st">&quot;alpha&quot;</span>)</span>
<span id="cb2-2"><a href="#cb2-2"></a><span class="co">#&gt; &#39;avalue&#39; automatically set to 1.8275e-01</span></span></code></pre></div>
<p><img src="data:image/png;base64,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" style="display: block; margin: auto;" /></p>
<p>To get the colour volume value, you can use the <code>summary.colspace()</code> function. The colour volume computed by the convex hull is contained in the <code>c.vol</code> column and the colour volume computed by the <span class="math inline">\(\alpha\)</span>-shape (with parameter <span class="math inline">\(\alpha^*\)</span>) is contained in the <code>a.vol</code> column:</p>
<div class="sourceCode" id="cb3"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb3-1"><a href="#cb3-1"></a><span class="kw">summary</span>(tcs_flowers)</span>
<span id="cb3-2"><a href="#cb3-2"></a><span class="co">#&gt; Colorspace &amp; visual model options:</span></span>
<span id="cb3-3"><a href="#cb3-3"></a><span class="co">#&gt;  * Colorspace: tcs </span></span>
<span id="cb3-4"><a href="#cb3-4"></a><span class="co">#&gt;  * Quantal catch: Qi </span></span>
<span id="cb3-5"><a href="#cb3-5"></a><span class="co">#&gt;  * Visual system, chromatic: avg.uv </span></span>
<span id="cb3-6"><a href="#cb3-6"></a><span class="co">#&gt;  * Visual system, achromatic: none </span></span>
<span id="cb3-7"><a href="#cb3-7"></a><span class="co">#&gt;  * Illuminant: ideal, scale = 1 (von Kries colour correction not applied) </span></span>
<span id="cb3-8"><a href="#cb3-8"></a><span class="co">#&gt;  * Background: ideal </span></span>
<span id="cb3-9"><a href="#cb3-9"></a><span class="co">#&gt;  * Relative: TRUE </span></span>
<span id="cb3-10"><a href="#cb3-10"></a><span class="co">#&gt;  * Max possible chromatic volume: 0.215735</span></span>
<span id="cb3-11"><a href="#cb3-11"></a><span class="co">#&gt; &#39;avalue&#39; automatically set to 1.8275e-01</span></span>
<span id="cb3-12"><a href="#cb3-12"></a><span class="co">#&gt;            centroid.u centroid.s centroid.m centroid.l      c.vol  rel.c.vol</span></span>
<span id="cb3-13"><a href="#cb3-13"></a><span class="co">#&gt; all.points 0.06025649  0.2375617   0.317973  0.3842088 0.01432726 0.06617479</span></span>
<span id="cb3-14"><a href="#cb3-14"></a><span class="co">#&gt;            colspan.m  colspan.v huedisp.m huedisp.v   mean.ra   max.ra</span></span>
<span id="cb3-15"><a href="#cb3-15"></a><span class="co">#&gt; all.points 0.2000963 0.01309332 0.7414951 0.2235526 0.8319508 0.999151</span></span>
<span id="cb3-16"><a href="#cb3-16"></a><span class="co">#&gt;                  a.vol</span></span>
<span id="cb3-17"><a href="#cb3-17"></a><span class="co">#&gt; all.points 0.006057976</span></span></code></pre></div>
<p>Alternatively, you can set the <span class="math inline">\(\alpha\)</span> parameter to the value of your choice via the <code>avalue</code> argument:</p>
<div class="sourceCode" id="cb4"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb4-1"><a href="#cb4-1"></a><span class="kw">plot</span>(tcs_flowers)</span>
<span id="cb4-2"><a href="#cb4-2"></a><span class="kw">vol</span>(tcs_flowers, <span class="dt">type =</span> <span class="st">&quot;alpha&quot;</span>, <span class="dt">avalue =</span> <span class="fl">0.5</span>)</span></code></pre></div>
<p><img src="data:image/png;base64,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" style="display: block; margin: auto;" /></p>
</div>
<div id="alpha-shapes-in-perceptually-uniform-spaces" class="section level1">
<h1><span class="math inline">\(\alpha\)</span>-shapes in perceptually uniform spaces</h1>
<p>In the previous section, we focused on <span class="math inline">\(\alpha\)</span>-shapes in chromaticity diagrams since it is the most common space where convex hulls (that <span class="math inline">\(\alpha\)</span>-shapes aim at replacing) are used. But it is also possible to use <span class="math inline">\(\alpha\)</span>-shapes in other spaces, such as perceptually uniform spaces.</p>
<p>Let’s first build this uniform space and look at the data points in this space:</p>
<div class="sourceCode" id="cb5"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb5-1"><a href="#cb5-1"></a>cd_flowers &lt;-<span class="st"> </span><span class="kw">coldist</span>(vis_flowers)</span>
<span id="cb5-2"><a href="#cb5-2"></a><span class="co">#&gt; Warning: Quantum catch are relative, distances may not be meaningful</span></span>
<span id="cb5-3"><a href="#cb5-3"></a><span class="co">#&gt; Calculating noise-weighted Euclidean distances</span></span>
<span id="cb5-4"><a href="#cb5-4"></a>xy_flowers &lt;-<span class="st"> </span><span class="kw">jnd2xyz</span>(cd_flowers)</span>
<span id="cb5-5"><a href="#cb5-5"></a><span class="kw">plot</span>(xy_flowers)</span></code></pre></div>
<p><img src="data:image/png;base64,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00xT7a61XgcgMF5gpQN+p35iFQj89ttvjkTuvPNOM3r0aIOm880335h5553X9OnTx6y88spm2WWXNYsuuqiZYIIJzJdffmlmm20288svv5RG53KChN544w3z+uuvmzFjxjhy4vPHH39sJp10UkdO008/vZlnnnnMEkssYVZccUWnOU022WSlcfShMxAQAXXGee72K//66y8zfPhwc9ttt5knn3zSkQaEMsssszhtZdVVV3Vks9RSS5mJJ5642/YsiCOg2BX/fyH7fPfddx05QVCvvPKKI6dx48aZzz77zEwxxRSOnGaYYQZHemhWEN9KK61k/va3v5UbWv9rUQREQC164mo97KefftrceOON5rHHHjPvvfee+fzzz93NvtxyyxnIhvfevXs7Eqh27FoJiHHZ5t5773WEN9dcc5n111/f7fOPP/4wb731VomcMPd4vfnmm+brr782U045pTPfIKcFFljAmX2eJMcfX7GUas9Z0dYTARXtjKRwPGgXQ4YMMQ899JC7qdEuJpxwQrPMMss4U2f55Zd3hIMZ1IjUSkAcF0SHmYbZxjHhT/riiy9MuWP59ddfHRFhxvGCmF599VW37Pvvv3dEis9ppplmMgsttJD7naussopBe5MUGwERULHPT8Wj++STT1xECnOKmxMn8e+//+58K0SkiEzht5ljjjkqjlXrCrUQ0AcffJB4DGg1HPu0005b6yGYn376qaQ1vfbaa86kw+/09ttvm59//tlpTTi+iczhOEfLAxeISpI/AiKg/M9B1UdARAozKhyRQgPgxuKJj68EssFEGW+88aoet94VayGgo446ygwaNMjg6I4K5tXpp59udt999+i/GvoOXhAbmhfk9OKLL5qxY8ead955x+CPQmuCnGaddVazyCKLGDTDvn37ushdQzvWxlUjoDB81VA1d0Vu1GHDhpk77rijFJHCF0LkiGjUgQce6MiG/BsiUs0Sjuvmm282Dz74oMH3wo1cjXDzx5EP20KiEETaMtVUUzmNB60nKpCnJydICbPuvvvuM7vttpvDk21JI5h99tldjhPkRBrBjDPOGB1K3xtAQATUAHhpbooJRR6Nj0jhF8FswITaddddHdkQFUqKSKV5LElj/fnnny7pkPA82gVaFv6cTTbZxAwdOrSs1oUJmERYk0wySdOTF/E5Ef7nFRXMWrQmCApyIseJ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1Wbbbbc1Cy+8sJl//vnNX3/9FUs+jDXxxBObZ555ptKw+n8HIzBhUX47F/L445fnQ9T98cYbryiH3NbHgWZz1113mdtvv9089dRT5qOPPjLffPONmW222cwKK6xg9ttvP7Psssuadddd13zxxRexWLD+JptsYmaYYQYz88wzm4UWWsj07t3brLrqqmaJJZaI3UYLOwuB8exNnVvI4tVXXzUHHXSQeeyxx5z/YLHFFjMnn3yy8x/40/DDDz+Y448/3txyyy3uQu/Xr5+5+OKLzfTTT+9W4cK+7bbbzPLLL+830XsdCODDGTp0qBk5cqR57733zFdffWWmm246s9xyy5m+ffu696WXXtpMNtlkXUbfYostzK233pqoBT344IPm888/N6+99pp58cUXzSuvvOLGJ1o21VRTmWmmmcbMOuusTqOCnDi/CyywQJd96Eu2CPDwx4zOgwpyIyAucJ6CODAPPPBA95Q8++yzzX333WeeeOIJw8WO7Lvvvu5JfMEFF5i//e1v7jta0HPPPee0IRFQ7Rfnyy+/bK6//nrz8MMPm7feessR+6STTuowhwAgc7QbyKGSvPnmm84Ui1vvlFNOMYccckjcv8x3331nXn/9dfcaO3aseeGFFwzvkB83wpRTTun2P/vssxseTBzP6quvbvguSReBPAmIk52L2AgJmldg1fvS/q3DMrBh3GCfffZxy+wTM7BmWWCfsKV1rNbktrvnnnvcMktggSWs0v/1oSsCNiIVnHrqqYGNSgVzzTVXMPnkkweWbAJrRgWHHnpoYLXH4OOPP+66UY3frIYTWG0psD6fwBKHO4eWfGoc5b+rM97jjz8eXHHFFYElsMCaecG8884bTDTRRO7YZ5xxxsCac+43HXDAAYEl0+DTTz/97wD6VBMCNnLp7qmaNkpp5dx8QGg4gwcPdk82z+eo5PgLfORk+PDhTutZb731/CpOVV9wwQXNnXfeadZZZ53Scn0wzmxCs0GLRMshP+fnn382iyyyiFlttdXMLrvs4vC2N3OqcHHO2Bem1vfff2/mnHNO54CudyeMx2vFFVfsNoQlS/PGG2+4FyY8mtNNN93kfFRoyFxDmI5zzz2307AZAxOS5ZLiIZAbAS211FKGV1jwBb3zzjvm4IMPdovHjRtnevTo4UgovB4+A/vECy/quM/4UG6++WZnno4ePdp88skn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" style="display: block; margin: auto;" /></p>
<p>High-level functions to build the <span class="math inline">\(\alpha\)</span>-shape directly in <code>pavo</code> have not yet been implemented but you can use the <code>alphashape3d</code> package directly to compute the <span class="math inline">\(\alpha\)</span>-shapes, its volume and display it in a 3D interactive plot.</p>
<div class="sourceCode" id="cb6"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb6-1"><a href="#cb6-1"></a><span class="kw">library</span>(alphashape3d)</span>
<span id="cb6-2"><a href="#cb6-2"></a>ashape_jnd &lt;-<span class="st"> </span><span class="kw">ashape3d</span>(<span class="kw">as.matrix</span>(xy_flowers), <span class="dt">alpha =</span> <span class="dv">10</span>)</span>
<span id="cb6-3"><a href="#cb6-3"></a><span class="kw">volume_ashape3d</span>(ashape_jnd)</span>
<span id="cb6-4"><a href="#cb6-4"></a><span class="co">#&gt; [1] 748.863</span></span></code></pre></div>
<div class="sourceCode" id="cb7"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb7-1"><a href="#cb7-1"></a><span class="kw">plot</span>(ashape_jnd)</span>
<span id="cb7-2"><a href="#cb7-2"></a><span class="co">#&gt; Device  1  : alpha =  10</span></span>
<span id="cb7-3"><a href="#cb7-3"></a><span class="co">#&gt; Warning in rgl.material(...): partial argument match of &#39;col&#39; to &#39;color&#39;</span></span>
<span id="cb7-4"><a href="#cb7-4"></a></span>
<span id="cb7-5"><a href="#cb7-5"></a><span class="co">#&gt; Warning in rgl.material(...): partial argument match of &#39;col&#39; to &#39;color&#39;</span></span>
<span id="cb7-6"><a href="#cb7-6"></a></span>
<span id="cb7-7"><a href="#cb7-7"></a><span class="co">#&gt; Warning in rgl.material(...): partial argument match of &#39;col&#39; to &#39;color&#39;</span></span></code></pre></div>
<script>/*
* Copyright (C) 2009 Apple Inc. All Rights Reserved.
*
* Redistribution and use in source and binary forms, with or without
* modification, are permitted provided that the following conditions
* are met:
* 1. Redistributions of source code must retain the above copyright
*    notice, this list of conditions and the following disclaimer.
* 2. Redistributions in binary form must reproduce the above copyright
*    notice, this list of conditions and the following disclaimer in the
*    documentation and/or other materials provided with the distribution.
*
* THIS SOFTWARE IS PROVIDED BY APPLE INC. ``AS IS'' AND ANY
* EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
* IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR
* PURPOSE ARE DISCLAIMED.  IN NO EVENT SHALL APPLE INC. OR
* CONTRIBUTORS BE LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL,
* EXEMPLARY, OR CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO,
* PROCUREMENT OF SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR
* PROFITS; OR BUSINESS INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY
* OF LIABILITY, WHETHER IN CONTRACT, STRICT LIABILITY, OR TORT
* (INCLUDING NEGLIGENCE OR OTHERWISE) ARISING IN ANY WAY OUT OF THE USE
* OF THIS SOFTWARE, EVEN IF ADVISED OF THE POSSIBILITY OF SUCH DAMAGE.
* Copyright (2016) Duncan Murdoch - fixed CanvasMatrix4.ortho,
* cleaned up.
*/
/*
CanvasMatrix4 class
This class implements a 4x4 matrix. It has functions which
duplicate the functionality of the OpenGL matrix stack and
glut functions.
IDL:
[
Constructor(in CanvasMatrix4 matrix),           // copy passed matrix into new CanvasMatrix4
Constructor(in sequence<float> array)           // create new CanvasMatrix4 with 16 floats (row major)
Constructor()                                   // create new CanvasMatrix4 with identity matrix
]
interface CanvasMatrix4 {
attribute float m11;
attribute float m12;
attribute float m13;
attribute float m14;
attribute float m21;
attribute float m22;
attribute float m23;
attribute float m24;
attribute float m31;
attribute float m32;
attribute float m33;
attribute float m34;
attribute float m41;
attribute float m42;
attribute float m43;
attribute float m44;
void load(in CanvasMatrix4 matrix);                 // copy the values from the passed matrix
void load(in sequence<float> array);                // copy 16 floats into the matrix
sequence<float> getAsArray();                       // return the matrix as an array of 16 floats
WebGLFloatArray getAsCanvasFloatArray();           // return the matrix as a WebGLFloatArray with 16 values
void makeIdentity();                                // replace the matrix with identity
void transpose();                                   // replace the matrix with its transpose
void invert();                                      // replace the matrix with its inverse
void translate(in float x, in float y, in float z); // multiply the matrix by passed translation values on the right
void scale(in float x, in float y, in float z);     // multiply the matrix by passed scale values on the right
void rotate(in float angle,                         // multiply the matrix by passed rotation values on the right
in float x, in float y, in float z);    // (angle is in degrees)
void multRight(in CanvasMatrix matrix);             // multiply the matrix by the passed matrix on the right
void multLeft(in CanvasMatrix matrix);              // multiply the matrix by the passed matrix on the left
void ortho(in float left, in float right,           // multiply the matrix by the passed ortho values on the right
in float bottom, in float top,
in float near, in float far);
void frustum(in float left, in float right,         // multiply the matrix by the passed frustum values on the right
in float bottom, in float top,
in float near, in float far);
void perspective(in float fovy, in float aspect,    // multiply the matrix by the passed perspective values on the right
in float zNear, in float zFar);
void lookat(in float eyex, in float eyey, in float eyez,    // multiply the matrix by the passed lookat
in float ctrx, in float ctry, in float ctrz,    // values on the right
in float upx, in float upy, in float upz);
}
*/
CanvasMatrix4 = function(m)
{
if (typeof m == 'object') {
if ("length" in m && m.length >= 16) {
this.load(m[0], m[1], m[2], m[3], m[4], m[5], m[6], m[7], m[8], m[9], m[10], m[11], m[12], m[13], m[14], m[15]);
return;
}
else if (m instanceof CanvasMatrix4) {
this.load(m);
return;
}
}
this.makeIdentity();
};
CanvasMatrix4.prototype.load = function()
{
if (arguments.length == 1 && typeof arguments[0] == 'object') {
var matrix = arguments[0];
if ("length" in matrix && matrix.length == 16) {
this.m11 = matrix[0];
this.m12 = matrix[1];
this.m13 = matrix[2];
this.m14 = matrix[3];
this.m21 = matrix[4];
this.m22 = matrix[5];
this.m23 = matrix[6];
this.m24 = matrix[7];
this.m31 = matrix[8];
this.m32 = matrix[9];
this.m33 = matrix[10];
this.m34 = matrix[11];
this.m41 = matrix[12];
this.m42 = matrix[13];
this.m43 = matrix[14];
this.m44 = matrix[15];
return;
}
if (arguments[0] instanceof CanvasMatrix4) {
this.m11 = matrix.m11;
this.m12 = matrix.m12;
this.m13 = matrix.m13;
this.m14 = matrix.m14;
this.m21 = matrix.m21;
this.m22 = matrix.m22;
this.m23 = matrix.m23;
this.m24 = matrix.m24;
this.m31 = matrix.m31;
this.m32 = matrix.m32;
this.m33 = matrix.m33;
this.m34 = matrix.m34;
this.m41 = matrix.m41;
this.m42 = matrix.m42;
this.m43 = matrix.m43;
this.m44 = matrix.m44;
return;
}
}
this.makeIdentity();
};
CanvasMatrix4.prototype.getAsArray = function()
{
return [
this.m11, this.m12, this.m13, this.m14,
this.m21, this.m22, this.m23, this.m24,
this.m31, this.m32, this.m33, this.m34,
this.m41, this.m42, this.m43, this.m44
];
};
CanvasMatrix4.prototype.getAsWebGLFloatArray = function()
{
return new WebGLFloatArray(this.getAsArray());
};
CanvasMatrix4.prototype.makeIdentity = function()
{
this.m11 = 1;
this.m12 = 0;
this.m13 = 0;
this.m14 = 0;
this.m21 = 0;
this.m22 = 1;
this.m23 = 0;
this.m24 = 0;
this.m31 = 0;
this.m32 = 0;
this.m33 = 1;
this.m34 = 0;
this.m41 = 0;
this.m42 = 0;
this.m43 = 0;
this.m44 = 1;
};
CanvasMatrix4.prototype.transpose = function()
{
var tmp = this.m12;
this.m12 = this.m21;
this.m21 = tmp;
tmp = this.m13;
this.m13 = this.m31;
this.m31 = tmp;
tmp = this.m14;
this.m14 = this.m41;
this.m41 = tmp;
tmp = this.m23;
this.m23 = this.m32;
this.m32 = tmp;
tmp = this.m24;
this.m24 = this.m42;
this.m42 = tmp;
tmp = this.m34;
this.m34 = this.m43;
this.m43 = tmp;
};
CanvasMatrix4.prototype.invert = function()
{
// Calculate the 4x4 determinant
// If the determinant is zero,
// then the inverse matrix is not unique.
var det = this._determinant4x4();
if (Math.abs(det) < 1e-8)
return null;
this._makeAdjoint();
// Scale the adjoint matrix to get the inverse
this.m11 /= det;
this.m12 /= det;
this.m13 /= det;
this.m14 /= det;
this.m21 /= det;
this.m22 /= det;
this.m23 /= det;
this.m24 /= det;
this.m31 /= det;
this.m32 /= det;
this.m33 /= det;
this.m34 /= det;
this.m41 /= det;
this.m42 /= det;
this.m43 /= det;
this.m44 /= det;
};
CanvasMatrix4.prototype.translate = function(x,y,z)
{
if (x === undefined)
x = 0;
if (y === undefined)
y = 0;
if (z === undefined)
z = 0;
var matrix = new CanvasMatrix4();
matrix.m41 = x;
matrix.m42 = y;
matrix.m43 = z;
this.multRight(matrix);
};
CanvasMatrix4.prototype.scale = function(x,y,z)
{
if (x === undefined)
x = 1;
if (z === undefined) {
if (y === undefined) {
y = x;
z = x;
}
else
z = 1;
}
else if (y === undefined)
y = x;
var matrix = new CanvasMatrix4();
matrix.m11 = x;
matrix.m22 = y;
matrix.m33 = z;
this.multRight(matrix);
};
CanvasMatrix4.prototype.rotate = function(angle,x,y,z)
{
// angles are in degrees. Switch to radians
angle = angle / 180 * Math.PI;
angle /= 2;
var sinA = Math.sin(angle);
var cosA = Math.cos(angle);
var sinA2 = sinA * sinA;
// normalize
var length = Math.sqrt(x * x + y * y + z * z);
if (length === 0) {
// bad vector, just use something reasonable
x = 0;
y = 0;
z = 1;
} else if (length != 1) {
x /= length;
y /= length;
z /= length;
}
var mat = new CanvasMatrix4();
// optimize case where axis is along major axis
if (x == 1 && y === 0 && z === 0) {
mat.m11 = 1;
mat.m12 = 0;
mat.m13 = 0;
mat.m21 = 0;
mat.m22 = 1 - 2 * sinA2;
mat.m23 = 2 * sinA * cosA;
mat.m31 = 0;
mat.m32 = -2 * sinA * cosA;
mat.m33 = 1 - 2 * sinA2;
mat.m14 = mat.m24 = mat.m34 = 0;
mat.m41 = mat.m42 = mat.m43 = 0;
mat.m44 = 1;
} else if (x === 0 && y == 1 && z === 0) {
mat.m11 = 1 - 2 * sinA2;
mat.m12 = 0;
mat.m13 = -2 * sinA * cosA;
mat.m21 = 0;
mat.m22 = 1;
mat.m23 = 0;
mat.m31 = 2 * sinA * cosA;
mat.m32 = 0;
mat.m33 = 1 - 2 * sinA2;
mat.m14 = mat.m24 = mat.m34 = 0;
mat.m41 = mat.m42 = mat.m43 = 0;
mat.m44 = 1;
} else if (x === 0 && y === 0 && z == 1) {
mat.m11 = 1 - 2 * sinA2;
mat.m12 = 2 * sinA * cosA;
mat.m13 = 0;
mat.m21 = -2 * sinA * cosA;
mat.m22 = 1 - 2 * sinA2;
mat.m23 = 0;
mat.m31 = 0;
mat.m32 = 0;
mat.m33 = 1;
mat.m14 = mat.m24 = mat.m34 = 0;
mat.m41 = mat.m42 = mat.m43 = 0;
mat.m44 = 1;
} else {
var x2 = x*x;
var y2 = y*y;
var z2 = z*z;
mat.m11 = 1 - 2 * (y2 + z2) * sinA2;
mat.m12 = 2 * (x * y * sinA2 + z * sinA * cosA);
mat.m13 = 2 * (x * z * sinA2 - y * sinA * cosA);
mat.m21 = 2 * (y * x * sinA2 - z * sinA * cosA);
mat.m22 = 1 - 2 * (z2 + x2) * sinA2;
mat.m23 = 2 * (y * z * sinA2 + x * sinA * cosA);
mat.m31 = 2 * (z * x * sinA2 + y * sinA * cosA);
mat.m32 = 2 * (z * y * sinA2 - x * sinA * cosA);
mat.m33 = 1 - 2 * (x2 + y2) * sinA2;
mat.m14 = mat.m24 = mat.m34 = 0;
mat.m41 = mat.m42 = mat.m43 = 0;
mat.m44 = 1;
}
this.multRight(mat);
};
CanvasMatrix4.prototype.multRight = function(mat)
{
var m11 = (this.m11 * mat.m11 + this.m12 * mat.m21 +
this.m13 * mat.m31 + this.m14 * mat.m41);
var m12 = (this.m11 * mat.m12 + this.m12 * mat.m22 +
this.m13 * mat.m32 + this.m14 * mat.m42);
var m13 = (this.m11 * mat.m13 + this.m12 * mat.m23 +
this.m13 * mat.m33 + this.m14 * mat.m43);
var m14 = (this.m11 * mat.m14 + this.m12 * mat.m24 +
this.m13 * mat.m34 + this.m14 * mat.m44);
var m21 = (this.m21 * mat.m11 + this.m22 * mat.m21 +
this.m23 * mat.m31 + this.m24 * mat.m41);
var m22 = (this.m21 * mat.m12 + this.m22 * mat.m22 +
this.m23 * mat.m32 + this.m24 * mat.m42);
var m23 = (this.m21 * mat.m13 + this.m22 * mat.m23 +
this.m23 * mat.m33 + this.m24 * mat.m43);
var m24 = (this.m21 * mat.m14 + this.m22 * mat.m24 +
this.m23 * mat.m34 + this.m24 * mat.m44);
var m31 = (this.m31 * mat.m11 + this.m32 * mat.m21 +
this.m33 * mat.m31 + this.m34 * mat.m41);
var m32 = (this.m31 * mat.m12 + this.m32 * mat.m22 +
this.m33 * mat.m32 + this.m34 * mat.m42);
var m33 = (this.m31 * mat.m13 + this.m32 * mat.m23 +
this.m33 * mat.m33 + this.m34 * mat.m43);
var m34 = (this.m31 * mat.m14 + this.m32 * mat.m24 +
this.m33 * mat.m34 + this.m34 * mat.m44);
var m41 = (this.m41 * mat.m11 + this.m42 * mat.m21 +
this.m43 * mat.m31 + this.m44 * mat.m41);
var m42 = (this.m41 * mat.m12 + this.m42 * mat.m22 +
this.m43 * mat.m32 + this.m44 * mat.m42);
var m43 = (this.m41 * mat.m13 + this.m42 * mat.m23 +
this.m43 * mat.m33 + this.m44 * mat.m43);
var m44 = (this.m41 * mat.m14 + this.m42 * mat.m24 +
this.m43 * mat.m34 + this.m44 * mat.m44);
this.m11 = m11;
this.m12 = m12;
this.m13 = m13;
this.m14 = m14;
this.m21 = m21;
this.m22 = m22;
this.m23 = m23;
this.m24 = m24;
this.m31 = m31;
this.m32 = m32;
this.m33 = m33;
this.m34 = m34;
this.m41 = m41;
this.m42 = m42;
this.m43 = m43;
this.m44 = m44;
};
CanvasMatrix4.prototype.multLeft = function(mat)
{
var m11 = (mat.m11 * this.m11 + mat.m12 * this.m21 +
mat.m13 * this.m31 + mat.m14 * this.m41);
var m12 = (mat.m11 * this.m12 + mat.m12 * this.m22 +
mat.m13 * this.m32 + mat.m14 * this.m42);
var m13 = (mat.m11 * this.m13 + mat.m12 * this.m23 +
mat.m13 * this.m33 + mat.m14 * this.m43);
var m14 = (mat.m11 * this.m14 + mat.m12 * this.m24 +
mat.m13 * this.m34 + mat.m14 * this.m44);
var m21 = (mat.m21 * this.m11 + mat.m22 * this.m21 +
mat.m23 * this.m31 + mat.m24 * this.m41);
var m22 = (mat.m21 * this.m12 + mat.m22 * this.m22 +
mat.m23 * this.m32 + mat.m24 * this.m42);
var m23 = (mat.m21 * this.m13 + mat.m22 * this.m23 +
mat.m23 * this.m33 + mat.m24 * this.m43);
var m24 = (mat.m21 * this.m14 + mat.m22 * this.m24 +
mat.m23 * this.m34 + mat.m24 * this.m44);
var m31 = (mat.m31 * this.m11 + mat.m32 * this.m21 +
mat.m33 * this.m31 + mat.m34 * this.m41);
var m32 = (mat.m31 * this.m12 + mat.m32 * this.m22 +
mat.m33 * this.m32 + mat.m34 * this.m42);
var m33 = (mat.m31 * this.m13 + mat.m32 * this.m23 +
mat.m33 * this.m33 + mat.m34 * this.m43);
var m34 = (mat.m31 * this.m14 + mat.m32 * this.m24 +
mat.m33 * this.m34 + mat.m34 * this.m44);
var m41 = (mat.m41 * this.m11 + mat.m42 * this.m21 +
mat.m43 * this.m31 + mat.m44 * this.m41);
var m42 = (mat.m41 * this.m12 + mat.m42 * this.m22 +
mat.m43 * this.m32 + mat.m44 * this.m42);
var m43 = (mat.m41 * this.m13 + mat.m42 * this.m23 +
mat.m43 * this.m33 + mat.m44 * this.m43);
var m44 = (mat.m41 * this.m14 + mat.m42 * this.m24 +
mat.m43 * this.m34 + mat.m44 * this.m44);
this.m11 = m11;
this.m12 = m12;
this.m13 = m13;
this.m14 = m14;
this.m21 = m21;
this.m22 = m22;
this.m23 = m23;
this.m24 = m24;
this.m31 = m31;
this.m32 = m32;
this.m33 = m33;
this.m34 = m34;
this.m41 = m41;
this.m42 = m42;
this.m43 = m43;
this.m44 = m44;
};
CanvasMatrix4.prototype.ortho = function(left, right, bottom, top, near, far)
{
var tx = (left + right) / (left - right);
var ty = (top + bottom) / (bottom - top);
var tz = (far + near) / (near - far);
var matrix = new CanvasMatrix4();
matrix.m11 = 2 / (right - left);
matrix.m12 = 0;
matrix.m13 = 0;
matrix.m14 = 0;
matrix.m21 = 0;
matrix.m22 = 2 / (top - bottom);
matrix.m23 = 0;
matrix.m24 = 0;
matrix.m31 = 0;
matrix.m32 = 0;
matrix.m33 = -2 / (far - near);
matrix.m34 = 0;
matrix.m41 = tx;
matrix.m42 = ty;
matrix.m43 = tz;
matrix.m44 = 1;
this.multRight(matrix);
};
CanvasMatrix4.prototype.frustum = function(left, right, bottom, top, near, far)
{
var matrix = new CanvasMatrix4();
var A = (right + left) / (right - left);
var B = (top + bottom) / (top - bottom);
var C = -(far + near) / (far - near);
var D = -(2 * far * near) / (far - near);
matrix.m11 = (2 * near) / (right - left);
matrix.m12 = 0;
matrix.m13 = 0;
matrix.m14 = 0;
matrix.m21 = 0;
matrix.m22 = 2 * near / (top - bottom);
matrix.m23 = 0;
matrix.m24 = 0;
matrix.m31 = A;
matrix.m32 = B;
matrix.m33 = C;
matrix.m34 = -1;
matrix.m41 = 0;
matrix.m42 = 0;
matrix.m43 = D;
matrix.m44 = 0;
this.multRight(matrix);
};
CanvasMatrix4.prototype.perspective = function(fovy, aspect, zNear, zFar)
{
var top = Math.tan(fovy * Math.PI / 360) * zNear;
var bottom = -top;
var left = aspect * bottom;
var right = aspect * top;
this.frustum(left, right, bottom, top, zNear, zFar);
};
CanvasMatrix4.prototype.lookat = function(eyex, eyey, eyez, centerx, centery, centerz, upx, upy, upz)
{
var matrix = new CanvasMatrix4();
// Make rotation matrix
// Z vector
var zx = eyex - centerx;
var zy = eyey - centery;
var zz = eyez - centerz;
var mag = Math.sqrt(zx * zx + zy * zy + zz * zz);
if (mag) {
zx /= mag;
zy /= mag;
zz /= mag;
}
// Y vector
var yx = upx;
var yy = upy;
var yz = upz;
// X vector = Y cross Z
xx =  yy * zz - yz * zy;
xy = -yx * zz + yz * zx;
xz =  yx * zy - yy * zx;
// Recompute Y = Z cross X
yx = zy * xz - zz * xy;
yy = -zx * xz + zz * xx;
yx = zx * xy - zy * xx;
// cross product gives area of parallelogram, which is < 1.0 for
// non-perpendicular unit-length vectors; so normalize x, y here
mag = Math.sqrt(xx * xx + xy * xy + xz * xz);
if (mag) {
xx /= mag;
xy /= mag;
xz /= mag;
}
mag = Math.sqrt(yx * yx + yy * yy + yz * yz);
if (mag) {
yx /= mag;
yy /= mag;
yz /= mag;
}
matrix.m11 = xx;
matrix.m12 = xy;
matrix.m13 = xz;
matrix.m14 = 0;
matrix.m21 = yx;
matrix.m22 = yy;
matrix.m23 = yz;
matrix.m24 = 0;
matrix.m31 = zx;
matrix.m32 = zy;
matrix.m33 = zz;
matrix.m34 = 0;
matrix.m41 = 0;
matrix.m42 = 0;
matrix.m43 = 0;
matrix.m44 = 1;
matrix.translate(-eyex, -eyey, -eyez);
this.multRight(matrix);
};
// Support functions
CanvasMatrix4.prototype._determinant2x2 = function(a, b, c, d)
{
return a * d - b * c;
};
CanvasMatrix4.prototype._determinant3x3 = function(a1, a2, a3, b1, b2, b3, c1, c2, c3)
{
return a1 * this._determinant2x2(b2, b3, c2, c3) -
b1 * this._determinant2x2(a2, a3, c2, c3) +
c1 * this._determinant2x2(a2, a3, b2, b3);
};
CanvasMatrix4.prototype._determinant4x4 = function()
{
var a1 = this.m11;
var b1 = this.m12;
var c1 = this.m13;
var d1 = this.m14;
var a2 = this.m21;
var b2 = this.m22;
var c2 = this.m23;
var d2 = this.m24;
var a3 = this.m31;
var b3 = this.m32;
var c3 = this.m33;
var d3 = this.m34;
var a4 = this.m41;
var b4 = this.m42;
var c4 = this.m43;
var d4 = this.m44;
return a1 * this._determinant3x3(b2, b3, b4, c2, c3, c4, d2, d3, d4) -
b1 * this._determinant3x3(a2, a3, a4, c2, c3, c4, d2, d3, d4) +
c1 * this._determinant3x3(a2, a3, a4, b2, b3, b4, d2, d3, d4) -
d1 * this._determinant3x3(a2, a3, a4, b2, b3, b4, c2, c3, c4);
};
CanvasMatrix4.prototype._makeAdjoint = function()
{
var a1 = this.m11;
var b1 = this.m12;
var c1 = this.m13;
var d1 = this.m14;
var a2 = this.m21;
var b2 = this.m22;
var c2 = this.m23;
var d2 = this.m24;
var a3 = this.m31;
var b3 = this.m32;
var c3 = this.m33;
var d3 = this.m34;
var a4 = this.m41;
var b4 = this.m42;
var c4 = this.m43;
var d4 = this.m44;
// Row column labeling reversed since we transpose rows & columns
this.m11  =   this._determinant3x3(b2, b3, b4, c2, c3, c4, d2, d3, d4);
this.m21  = - this._determinant3x3(a2, a3, a4, c2, c3, c4, d2, d3, d4);
this.m31  =   this._determinant3x3(a2, a3, a4, b2, b3, b4, d2, d3, d4);
this.m41  = - this._determinant3x3(a2, a3, a4, b2, b3, b4, c2, c3, c4);
this.m12  = - this._determinant3x3(b1, b3, b4, c1, c3, c4, d1, d3, d4);
this.m22  =   this._determinant3x3(a1, a3, a4, c1, c3, c4, d1, d3, d4);
this.m32  = - this._determinant3x3(a1, a3, a4, b1, b3, b4, d1, d3, d4);
this.m42  =   this._determinant3x3(a1, a3, a4, b1, b3, b4, c1, c3, c4);
this.m13  =   this._determinant3x3(b1, b2, b4, c1, c2, c4, d1, d2, d4);
this.m23  = - this._determinant3x3(a1, a2, a4, c1, c2, c4, d1, d2, d4);
this.m33  =   this._determinant3x3(a1, a2, a4, b1, b2, b4, d1, d2, d4);
this.m43  = - this._determinant3x3(a1, a2, a4, b1, b2, b4, c1, c2, c4);
this.m14  = - this._determinant3x3(b1, b2, b3, c1, c2, c3, d1, d2, d3);
this.m24  =   this._determinant3x3(a1, a2, a3, c1, c2, c3, d1, d2, d3);
this.m34  = - this._determinant3x3(a1, a2, a3, b1, b2, b3, d1, d2, d3);
this.m44  =   this._determinant3x3(a1, a2, a3, b1, b2, b3, c1, c2, c3);
};</script>
<script>// To generate the help pages for this library, use
// jsdoc --destination ../../../doc/rglwidgetClass --template ~/node_modules/jsdoc-baseline rglClass.src.js
// To validate, use
// setwd(".../inst/htmlwidgets/lib/rglClass")
// hints <- js::jshint(readLines("rglClass.src.js"))
// hints[, c("line", "reason")]
/**
* The class of an rgl widget
* @class
*/
rglwidgetClass = function() {
this.canvas = null;
this.userMatrix = new CanvasMatrix4();
this.types = [];
this.prMatrix = new CanvasMatrix4();
this.mvMatrix = new CanvasMatrix4();
this.vp = null;
this.prmvMatrix = null;
this.origs = null;
this.gl = null;
this.scene = null;
this.select = {state: "inactive", subscene: null, region: {p1: {x:0, y:0}, p2: {x:0, y:0}}};
this.drawing = false;
};
/**
* Multiply matrix by vector
* @returns {number[]}
* @param M {number[][]} Left operand
* @param v {number[]} Right operand
*/
rglwidgetClass.prototype.multMV = function(M, v) {
return [ M.m11 * v[0] + M.m12 * v[1] + M.m13 * v[2] + M.m14 * v[3],
M.m21 * v[0] + M.m22 * v[1] + M.m23 * v[2] + M.m24 * v[3],
M.m31 * v[0] + M.m32 * v[1] + M.m33 * v[2] + M.m34 * v[3],
M.m41 * v[0] + M.m42 * v[1] + M.m43 * v[2] + M.m44 * v[3]
];
};
/**
* Multiply row vector by Matrix
* @returns {number[]}
* @param v {number[]} left operand
* @param M {number[][]} right operand
*/
rglwidgetClass.prototype.multVM = function(v, M) {
return [ M.m11 * v[0] + M.m21 * v[1] + M.m31 * v[2] + M.m41 * v[3],
M.m12 * v[0] + M.m22 * v[1] + M.m32 * v[2] + M.m42 * v[3],
M.m13 * v[0] + M.m23 * v[1] + M.m33 * v[2] + M.m43 * v[3],
M.m14 * v[0] + M.m24 * v[1] + M.m34 * v[2] + M.m44 * v[3]
];
};
/**
* Euclidean length of a vector
* @returns {number}
* @param v {number[]}
*/
rglwidgetClass.prototype.vlen = function(v) {
return Math.sqrt(this.dotprod(v, v));
};
/**
* Dot product of two vectors
* @instance rglwidgetClass
* @returns {number}
* @param a {number[]}
* @param b {number[]}
*/
rglwidgetClass.prototype.dotprod = function(a, b) {
return a[0]*b[0] + a[1]*b[1] + a[2]*b[2];
};
/**
* Cross product of two vectors
* @returns {number[]}
* @param a {number[]}
* @param b {number[]}
*/
rglwidgetClass.prototype.xprod = function(a, b) {
return [a[1]*b[2] - a[2]*b[1],
a[2]*b[0] - a[0]*b[2],
a[0]*b[1] - a[1]*b[0]];
};
/**
* Bind vectors or matrices by columns
* @returns {number[][]}
* @param a {number[]|number[][]}
* @param b {number[]|number[][]}
*/
rglwidgetClass.prototype.cbind = function(a, b) {
if (b.length < a.length)
b = this.repeatToLen(b, a.length);
else if (a.length < b.length)
a = this.repeatToLen(a, b.length);
return a.map(function(currentValue, index, array) {
return currentValue.concat(b[index]);
});
};
/**
* Swap elements
* @returns {any[]}
* @param a {any[]}
* @param i {number} Element to swap
* @param j {number} Other element to swap
*/
rglwidgetClass.prototype.swap = function(a, i, j) {
var temp = a[i];
a[i] = a[j];
a[j] = temp;
};
/**
* Flatten a matrix into a vector
* @returns {any[]}
* @param a {any[][]}
*/
rglwidgetClass.prototype.flatten = function(arr, result) {
var value;
if (typeof result === "undefined") result = [];
for (var i = 0, length = arr.length; i < length; i++) {
value = arr[i];
if (Array.isArray(value)) {
this.flatten(value, result);
} else {
result.push(value);
}
}
return result;
};
/**
* set element of 1d or 2d array as if it was flattened.
* Column major, zero based!
* @returns {any[]|any[][]}
* @param {any[]|any[][]} a - array
* @param {number} i - element
* @param {any} value
*/
rglwidgetClass.prototype.setElement = function(a, i, value) {
if (Array.isArray(a[0])) {
var dim = a.length,
col = Math.floor(i/dim),
row = i % dim;
a[row][col] = value;
} else {
a[i] = value;
}
};
/**
* Transpose an array
* @returns {any[][]}
* @param {any[][]} a
*/
rglwidgetClass.prototype.transpose = function(a) {
var newArray = [],
n = a.length,
m = a[0].length,
i;
for(i = 0; i < m; i++){
newArray.push([]);
}
for(i = 0; i < n; i++){
for(var j = 0; j < m; j++){
newArray[j].push(a[i][j]);
}
}
return newArray;
};
/**
* Calculate sum of squares of a numeric vector
* @returns {number}
* @param {number[]} x
*/
rglwidgetClass.prototype.sumsq = function(x) {
var result = 0, i;
for (i=0; i < x.length; i++)
result += x[i]*x[i];
return result;
};
/**
* Convert a matrix to a CanvasMatrix4
* @returns {CanvasMatrix4}
* @param {number[][]|number[]} mat
*/
rglwidgetClass.prototype.toCanvasMatrix4 = function(mat) {
if (mat instanceof CanvasMatrix4)
return mat;
var result = new CanvasMatrix4();
mat = this.flatten(this.transpose(mat));
result.load(mat);
return result;
};
/**
* Convert an R-style numeric colour string to an rgb vector
* @returns {number[]}
* @param {string} s
*/
rglwidgetClass.prototype.stringToRgb = function(s) {
s = s.replace("#", "");
var bigint = parseInt(s, 16);
return [((bigint >> 16) & 255)/255,
((bigint >> 8) & 255)/255,
(bigint & 255)/255];
};
/**
* Take a component-by-component product of two 3 vectors
* @returns {number[]}
* @param {number[]} x
* @param {number[]} y
*/
rglwidgetClass.prototype.componentProduct = function(x, y) {
if (typeof y === "undefined") {
this.alertOnce("Bad arg to componentProduct");
}
var result = new Float32Array(3), i;
for (i = 0; i<3; i++)
result[i] = x[i]*y[i];
return result;
};
/**
* Get next higher power of two
* @returns { number }
* @param { number } value - input value
*/
rglwidgetClass.prototype.getPowerOfTwo = function(value) {
var pow = 1;
while(pow<value) {
pow *= 2;
}
return pow;
};
/**
* Unique entries
* @returns { any[] }
* @param { any[] } arr - An array
*/
rglwidgetClass.prototype.unique = function(arr) {
arr = [].concat(arr);
return arr.filter(function(value, index, self) {
return self.indexOf(value) === index;
});
};
/**
* Shallow compare of arrays
* @returns { boolean }
* @param { any[] } a - An array
* @param { any[] } b - Another array
*/
rglwidgetClass.prototype.equalArrays = function(a, b) {
return a === b || (a && b &&
a.length === b.length &&
a.every(function(v, i) {return v === b[i];}));
};
/**
* Repeat an array to a desired length
* @returns {any[]}
* @param {any | any[]} arr The input array
* @param {number} len The desired output length
*/
rglwidgetClass.prototype.repeatToLen = function(arr, len) {
arr = [].concat(arr);
while (arr.length < len/2)
arr = arr.concat(arr);
return arr.concat(arr.slice(0, len - arr.length));
};
/**
* Give a single alert message, not to be repeated.
* @param {string} msg  The message to give.
*/
rglwidgetClass.prototype.alertOnce = function(msg) {
if (typeof this.alerted !== "undefined")
return;
this.alerted = true;
alert(msg);
};
rglwidgetClass.prototype.f_is_lit = 1;
rglwidgetClass.prototype.f_is_smooth = 2;
rglwidgetClass.prototype.f_has_texture = 4;
rglwidgetClass.prototype.f_depth_sort = 8;
rglwidgetClass.prototype.f_fixed_quads = 16;
rglwidgetClass.prototype.f_is_transparent = 32;
rglwidgetClass.prototype.f_is_lines = 64;
rglwidgetClass.prototype.f_sprites_3d = 128;
rglwidgetClass.prototype.f_sprite_3d = 256;
rglwidgetClass.prototype.f_is_subscene = 512;
rglwidgetClass.prototype.f_is_clipplanes = 1024;
rglwidgetClass.prototype.f_fixed_size = 2048;
rglwidgetClass.prototype.f_is_points = 4096;
rglwidgetClass.prototype.f_is_twosided = 8192;
rglwidgetClass.prototype.f_fat_lines = 16384;
rglwidgetClass.prototype.f_is_brush = 32768;
/**
* Which list does a particular id come from?
* @returns { string }
* @param {number} id The id to look up.
*/
rglwidgetClass.prototype.whichList = function(id) {
var obj = this.getObj(id),
flags = obj.flags;
if (obj.type === "light")
return "lights";
if (flags & this.f_is_subscene)
return "subscenes";
if (flags & this.f_is_clipplanes)
return "clipplanes";
if (flags & this.f_is_transparent)
return "transparent";
return "opaque";
};
/**
* Get an object by id number.
* @returns { Object }
* @param {number} id
*/
rglwidgetClass.prototype.getObj = function(id) {
if (typeof id !== "number") {
this.alertOnce("getObj id is "+typeof id);
}
return this.scene.objects[id];
};
/**
* Get ids of a particular type from a subscene or the whole scene
* @returns { number[] }
* @param {string} type What type of object?
* @param {number} subscene  Which subscene?  If not given, find in the whole scene
*/
rglwidgetClass.prototype.getIdsByType = function(type, subscene) {
var
result = [], i, self = this;
if (typeof subscene === "undefined") {
Object.keys(this.scene.objects).forEach(
function(key) {
key = parseInt(key, 10);
if (self.getObj(key).type === type)
result.push(key);
});
} else {
ids = this.getObj(subscene).objects;
for (i=0; i < ids.length; i++) {
if (this.getObj(ids[i]).type === type) {
result.push(ids[i]);
}
}
}
return result;
};
/**
* Get a particular material property for an id
* @returns { any }
* @param {number} id  Which object?
* @param {string} property Which material property?
*/
rglwidgetClass.prototype.getMaterial = function(id, property) {
var obj = this.getObj(id), mat;
if (typeof obj.material === "undefined")
console.error("material undefined");
mat = obj.material[property];
if (typeof mat === "undefined")
mat = this.scene.material[property];
return mat;
};
/**
* Is a particular id in a subscene?
* @returns { boolean }
* @param {number} id Which id?
* @param {number} subscene Which subscene id?
*/
rglwidgetClass.prototype.inSubscene = function(id, subscene) {
return this.getObj(subscene).objects.indexOf(id) > -1;
};
/**
* Add an id to a subscene.
* @param {number} id Which id?
* @param {number} subscene Which subscene id?
*/
rglwidgetClass.prototype.addToSubscene = function(id, subscene) {
var thelist,
thesub = this.getObj(subscene),
ids = [id],
obj = this.getObj(id), i;
if (typeof obj != "undefined" && typeof (obj.newIds) !== "undefined") {
ids = ids.concat(obj.newIds);
}
thesub.objects = [].concat(thesub.objects);
for (i = 0; i < ids.length; i++) {
id = ids[i];
if (thesub.objects.indexOf(id) == -1) {
thelist = this.whichList(id);
thesub.objects.push(id);
thesub[thelist].push(id);
}
}
};
/**
* Delete an id from a subscene
* @param { number } id - the id to add
* @param { number } subscene - the id of the subscene
*/
rglwidgetClass.prototype.delFromSubscene = function(id, subscene) {
var thelist,
thesub = this.getObj(subscene),
obj = this.getObj(id),
ids = [id], i;
if (typeof obj !== "undefined" && typeof (obj.newIds) !== "undefined")
ids = ids.concat(obj.newIds);
thesub.objects = [].concat(thesub.objects); // It might be a scalar
for (j=0; j<ids.length;j++) {
id = ids[j];
i = thesub.objects.indexOf(id);
if (i > -1) {
thesub.objects.splice(i, 1);
thelist = this.whichList(id);
i = thesub[thelist].indexOf(id);
thesub[thelist].splice(i, 1);
}
}
};
/**
* Set the ids in a subscene
* @param { number[] } ids - the ids to set
* @param { number } subsceneid - the id of the subscene
*/
rglwidgetClass.prototype.setSubsceneEntries = function(ids, subsceneid) {
var sub = this.getObj(subsceneid);
sub.objects = ids;
this.initSubscene(subsceneid);
};
/**
* Get the ids in a subscene
* @returns {number[]}
* @param { number } subscene - the id of the subscene
*/
rglwidgetClass.prototype.getSubsceneEntries = function(subscene) {
return this.getObj(subscene).objects;
};
/**
* Get the ids of the subscenes within a subscene
* @returns { number[] }
* @param { number } subscene - the id of the subscene
*/
rglwidgetClass.prototype.getChildSubscenes = function(subscene) {
return this.getObj(subscene).subscenes;
};
/**
* Start drawing
* @returns { boolean } Previous state
*/
rglwidgetClass.prototype.startDrawing = function() {
var value = this.drawing;
this.drawing = true;
return value;
};
/**
* Stop drawing and check for context loss
* @param { boolean } saved - Previous state
*/
rglwidgetClass.prototype.stopDrawing = function(saved) {
this.drawing = saved;
if (!saved && this.gl && this.gl.isContextLost())
this.restartCanvas();
};
/**
* Generate the vertex shader for an object
* @returns {string}
* @param { number } id - Id of object
*/
rglwidgetClass.prototype.getVertexShader = function(id) {
var obj = this.getObj(id),
userShader = obj.userVertexShader,
flags = obj.flags,
type = obj.type,
is_lit = flags & this.f_is_lit,
has_texture = flags & this.f_has_texture,
fixed_quads = flags & this.f_fixed_quads,
sprites_3d = flags & this.f_sprites_3d,
sprite_3d = flags & this.f_sprite_3d,
nclipplanes = this.countClipplanes(),
fixed_size = flags & this.f_fixed_size,
is_points = flags & this.f_is_points,
is_twosided = flags & this.f_is_twosided,
fat_lines = flags & this.f_fat_lines,
is_brush = flags & this.f_is_brush,
result;
if (type === "clipplanes" || sprites_3d) return;
if (typeof userShader !== "undefined") return userShader;
result = "  /* ****** "+type+" object "+id+" vertex shader ****** */\n"+
"  attribute vec3 aPos;\n"+
"  attribute vec4 aCol;\n"+
" uniform mat4 mvMatrix;\n"+
" uniform mat4 prMatrix;\n"+
" varying vec4 vCol;\n"+
" varying vec4 vPosition;\n";
if ((is_lit && !fixed_quads && !is_brush) || sprite_3d)
result = result + "  attribute vec3 aNorm;\n"+
" uniform mat4 normMatrix;\n"+
" varying vec3 vNormal;\n";
if (has_texture || type === "text")
result = result + " attribute vec2 aTexcoord;\n"+
" varying vec2 vTexcoord;\n";
if (fixed_size)
result = result + "  uniform vec2 textScale;\n";
if (fixed_quads)
result = result + "  attribute vec2 aOfs;\n";
else if (sprite_3d)
result = result + "  uniform vec3 uOrig;\n"+
"  uniform float uSize;\n"+
"  uniform mat4 usermat;\n";
if (is_twosided)
result = result + "  attribute vec3 aPos1;\n"+
"  attribute vec3 aPos2;\n"+
"  varying float normz;\n";
if (fat_lines) {
result = result +   "  attribute vec3 aNext;\n"+
"  attribute vec2 aPoint;\n"+
"  varying vec2 vPoint;\n"+
"  varying float vLength;\n"+
"  uniform float uAspect;\n"+
"  uniform float uLwd;\n";
}
result = result + "  void main(void) {\n";
if ((nclipplanes || (!fixed_quads && !sprite_3d)) && !is_brush)
result = result + "    vPosition = mvMatrix * vec4(aPos, 1.);\n";
if (!fixed_quads && !sprite_3d && !is_brush)
result = result + "    gl_Position = prMatrix * vPosition;\n";
if (is_points) {
var size = this.getMaterial(id, "size");
result = result + "    gl_PointSize = "+size.toFixed(1)+";\n";
}
result = result + "    vCol = aCol;\n";
if (is_lit && !fixed_quads && !sprite_3d && !is_brush)
result = result + "    vNormal = normalize((normMatrix * vec4(aNorm, 1.)).xyz);\n";
if (has_texture || type == "text")
result = result + "    vTexcoord = aTexcoord;\n";
if (fixed_size)
result = result + "    vec4 pos = prMatrix * mvMatrix * vec4(aPos, 1.);\n"+
"   pos = pos/pos.w;\n"+
"   gl_Position = pos + vec4(aOfs*textScale, 0.,0.);\n";
if (type == "sprites" && !fixed_size)
result = result + "    vec4 pos = mvMatrix * vec4(aPos, 1.);\n"+
"   pos = pos/pos.w + vec4(aOfs, 0., 0.);\n"+
"   gl_Position = prMatrix*pos;\n";
if (sprite_3d)
result = result + "   vNormal = normalize((normMatrix * vec4(aNorm, 1.)).xyz);\n"+
"   vec4 pos = mvMatrix * vec4(uOrig, 1.);\n"+
"   vPosition = pos/pos.w + vec4(uSize*(vec4(aPos, 1.)*usermat).xyz,0.);\n"+
"   gl_Position = prMatrix * vPosition;\n";
if (is_twosided)
result = result + "   vec4 pos1 = prMatrix*(mvMatrix*vec4(aPos1, 1.));\n"+
"   pos1 = pos1/pos1.w - gl_Position/gl_Position.w;\n"+
"   vec4 pos2 = prMatrix*(mvMatrix*vec4(aPos2, 1.));\n"+
"   pos2 = pos2/pos2.w - gl_Position/gl_Position.w;\n"+
"   normz = pos1.x*pos2.y - pos1.y*pos2.x;\n";
if (fat_lines) 
/* This code was inspired by Matt Deslauriers' code in https://mattdesl.svbtle.com/drawing-lines-is-hard */
result = result + "   vec2 aspectVec = vec2(uAspect, 1.0);\n"+
"   mat4 projViewModel = prMatrix * mvMatrix;\n"+
"   vec4 currentProjected = projViewModel * vec4(aPos, 1.0);\n"+
"   currentProjected = currentProjected/currentProjected.w;\n"+
"   vec4 nextProjected = projViewModel * vec4(aNext, 1.0);\n"+
"   vec2 currentScreen = currentProjected.xy * aspectVec;\n"+
"   vec2 nextScreen = (nextProjected.xy / nextProjected.w) * aspectVec;\n"+
"   float len = uLwd;\n"+
"   vec2 dir = vec2(1.0, 0.0);\n"+
"   vPoint = aPoint;\n"+
"   vLength = length(nextScreen - currentScreen)/2.0;\n"+
"   vLength = vLength/(vLength + len);\n"+
"   if (vLength > 0.0) {\n"+
"     dir = normalize(nextScreen - currentScreen);\n"+
"   }\n"+
"   vec2 normal = vec2(-dir.y, dir.x);\n"+
"   dir.x /= uAspect;\n"+
"   normal.x /= uAspect;\n"+
"   vec4 offset = vec4(len*(normal*aPoint.x*aPoint.y - dir), 0.0, 0.0);\n"+
"   gl_Position = currentProjected + offset;\n";
if (is_brush)
result = result + "   gl_Position = vec4(aPos, 1.);\n";
result = result + "  }\n";
// console.log(result);
return result;
};
/**
* Generate the fragment shader for an object
* @returns {string}
* @param { number } id - Id of object
*/
rglwidgetClass.prototype.getFragmentShader = function(id) {
var obj = this.getObj(id),
userShader = obj.userFragmentShader,
flags = obj.flags,
type = obj.type,
is_lit = flags & this.f_is_lit,
has_texture = flags & this.f_has_texture,
fixed_quads = flags & this.f_fixed_quads,
sprites_3d = flags & this.f_sprites_3d,
is_twosided = (flags & this.f_is_twosided) > 0,
fat_lines = flags & this.f_fat_lines,
is_transparent = flags & this.f_is_transparent,
nclipplanes = this.countClipplanes(), i,
texture_format, nlights,
result;
if (type === "clipplanes" || sprites_3d) return;
if (typeof userShader !== "undefined") return userShader;
if (has_texture)
texture_format = this.getMaterial(id, "textype");
result = "/* ****** "+type+" object "+id+" fragment shader ****** */\n"+
"#ifdef GL_ES\n"+
"#ifdef GL_FRAGMENT_PRECISION_HIGH\n"+
"  precision highp float;\n"+
"#else\n"+
"  precision mediump float;\n"+
"#endif\n"+
"#endif\n"+
"  varying vec4 vCol; // carries alpha\n"+
"  varying vec4 vPosition;\n";
if (has_texture || type === "text")
result = result + "  varying vec2 vTexcoord;\n"+
" uniform sampler2D uSampler;\n";
if (is_lit && !fixed_quads)
result = result + "  varying vec3 vNormal;\n";
for (i = 0; i < nclipplanes; i++)
result = result + "  uniform vec4 vClipplane"+i+";\n";
if (is_lit) {
nlights = this.countLights();
if (nlights)
result = result + "  uniform mat4 mvMatrix;\n";
else
is_lit = false;
}
if (is_lit) {
result = result + "   uniform vec3 emission;\n"+
"   uniform float shininess;\n";
for (i=0; i < nlights; i++) {
result = result + "   uniform vec3 ambient" + i + ";\n"+
"   uniform vec3 specular" + i +"; // light*material\n"+
"   uniform vec3 diffuse" + i + ";\n"+
"   uniform vec3 lightDir" + i + ";\n"+
"   uniform bool viewpoint" + i + ";\n"+
"   uniform bool finite" + i + ";\n";
}
}
if (is_twosided)
result = result + "   uniform bool front;\n"+
"   varying float normz;\n";
if (fat_lines)
result = result + "   varying vec2 vPoint;\n"+
"   varying float vLength;\n";
result = result + "  void main(void) {\n";
if (fat_lines) {
result = result + "    vec2 point = vPoint;\n"+
"    bool neg = point.y < 0.0;\n"+
"    point.y = neg ? "+
"      (point.y + vLength)/(1.0 - vLength) :\n"+
"     -(point.y - vLength)/(1.0 - vLength);\n";
if (is_transparent && type == "linestrip")
result = result+"    if (neg && length(point) <= 1.0) discard;\n";
result = result + "    point.y = min(point.y, 0.0);\n"+
"    if (length(point) > 1.0) discard;\n";
}
for (i=0; i < nclipplanes;i++)
result = result + "    if (dot(vPosition, vClipplane"+i+") < 0.0) discard;\n";
if (fixed_quads) {
result = result +   "    vec3 n = vec3(0., 0., 1.);\n";
} else if (is_lit) {
result = result +   "    vec3 n = normalize(vNormal);\n";
}
if (is_twosided) {
result = result +   "    if ((normz <= 0.) != front) discard;\n";
}
if (is_lit) {
result = result + "    vec3 eye = normalize(-vPosition.xyz);\n"+
"   vec3 lightdir;\n"+
"   vec4 colDiff;\n"+
"   vec3 halfVec;\n"+
"   vec4 lighteffect = vec4(emission, 0.);\n"+
"   vec3 col;\n"+
"   float nDotL;\n";
if (!fixed_quads) {
result = result +   "   n = -faceforward(n, n, eye);\n";
}
for (i=0; i < nlights; i++) {
result = result + "   colDiff = vec4(vCol.rgb * diffuse" + i + ", vCol.a);\n"+
"   lightdir = lightDir" + i + ";\n"+
"   if (!viewpoint" + i +")\n"+
"     lightdir = (mvMatrix * vec4(lightdir, 1.)).xyz;\n"+
"   if (!finite" + i + ") {\n"+
"     halfVec = normalize(lightdir + eye);\n"+
"   } else {\n"+
"     lightdir = normalize(lightdir - vPosition.xyz);\n"+
"     halfVec = normalize(lightdir + eye);\n"+
"   }\n"+
"    col = ambient" + i + ";\n"+
"   nDotL = dot(n, lightdir);\n"+
"   col = col + max(nDotL, 0.) * colDiff.rgb;\n"+
"   col = col + pow(max(dot(halfVec, n), 0.), shininess) * specular" + i + ";\n"+
"   lighteffect = lighteffect + vec4(col, colDiff.a);\n";
}
} else {
result = result +   "   vec4 colDiff = vCol;\n"+
"    vec4 lighteffect = colDiff;\n";
}
if (type === "text")
result = result +   "    vec4 textureColor = lighteffect*texture2D(uSampler, vTexcoord);\n";
if (has_texture) {
result = result + {
rgb:            "   vec4 textureColor = lighteffect*vec4(texture2D(uSampler, vTexcoord).rgb, 1.);\n",
rgba:           "   vec4 textureColor = lighteffect*texture2D(uSampler, vTexcoord);\n",
alpha:          "   vec4 textureColor = texture2D(uSampler, vTexcoord);\n"+
"   float luminance = dot(vec3(1.,1.,1.), textureColor.rgb)/3.;\n"+
"   textureColor =  vec4(lighteffect.rgb, lighteffect.a*luminance);\n",
luminance:      "   vec4 textureColor = vec4(lighteffect.rgb*dot(texture2D(uSampler, vTexcoord).rgb, vec3(1.,1.,1.))/3., lighteffect.a);\n",
"luminance.alpha":"    vec4 textureColor = texture2D(uSampler, vTexcoord);\n"+
"   float luminance = dot(vec3(1.,1.,1.),textureColor.rgb)/3.;\n"+
"   textureColor = vec4(lighteffect.rgb*luminance, lighteffect.a*textureColor.a);\n"
}[texture_format]+
"   gl_FragColor = textureColor;\n";
} else if (type === "text") {
result = result +   "    if (textureColor.a < 0.1)\n"+
"     discard;\n"+
"   else\n"+
"     gl_FragColor = textureColor;\n";
} else
result = result +   "   gl_FragColor = lighteffect;\n";
//if (fat_lines)
//  result = result +   "   gl_FragColor = vec4(0.0, abs(point.x), abs(point.y), 1.0);"
result = result + "  }\n";
// console.log(result);
return result;
};
/**
* Call gl functions to create and compile shader
* @returns {Object}
* @param { number } shaderType - gl code for shader type
* @param { string } code - code for the shader
*/
rglwidgetClass.prototype.getShader = function(shaderType, code) {
var gl = this.gl, shader;
shader = gl.createShader(shaderType);
gl.shaderSource(shader, code);
gl.compileShader(shader);
if (!gl.getShaderParameter(shader, gl.COMPILE_STATUS) && !gl.isContextLost())
alert(gl.getShaderInfoLog(shader));
return shader;
};
/**
* Handle a texture after its image has been loaded
* @param { Object } texture - the gl texture object
* @param { Object } textureCanvas - the canvas holding the image
*/
rglwidgetClass.prototype.handleLoadedTexture = function(texture, textureCanvas) {
var gl = this.gl || this.initGL();
gl.pixelStorei(gl.UNPACK_FLIP_Y_WEBGL, true);
gl.bindTexture(gl.TEXTURE_2D, texture);
gl.texImage2D(gl.TEXTURE_2D, 0, gl.RGBA, gl.RGBA, gl.UNSIGNED_BYTE, textureCanvas);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MAG_FILTER, gl.LINEAR);
gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR_MIPMAP_NEAREST);
gl.generateMipmap(gl.TEXTURE_2D);
gl.bindTexture(gl.TEXTURE_2D, null);
};
/**
* Get maximum dimension of texture in current browser.
* @returns {number}
*/
rglwidgetClass.prototype.getMaxTexSize = function() {
var gl = this.gl || this.initGL();  
return Math.min(4096, gl.getParameter(gl.MAX_TEXTURE_SIZE));
};
/**
* Load an image to a texture
* @param { string } uri - The image location
* @param { Object } texture - the gl texture object
*/
rglwidgetClass.prototype.loadImageToTexture = function(uri, texture) {
var canvas = this.textureCanvas,
ctx = canvas.getContext("2d"),
image = new Image(),
self = this;
image.onload = function() {
var w = image.width,
h = image.height,
canvasX = self.getPowerOfTwo(w),
canvasY = self.getPowerOfTwo(h),
gl = self.gl || self.initGL(),
maxTexSize = self.getMaxTexSize();
while (canvasX > 1 && canvasY > 1 && (canvasX > maxTexSize || canvasY > maxTexSize)) {
canvasX /= 2;
canvasY /= 2;
}
canvas.width = canvasX;
canvas.height = canvasY;
ctx.imageSmoothingEnabled = true;
ctx.drawImage(image, 0, 0, canvasX, canvasY);
self.handleLoadedTexture(texture, canvas);
self.drawScene();
};
image.src = uri;
};
/**
* Draw text to the texture canvas
* @returns { Object } object with text measurements
* @param { string } text - the text
* @param { number } cex - expansion
* @param { string } family - font family
* @param { number } font - font number
*/
rglwidgetClass.prototype.drawTextToCanvas = function(text, cex, family, font) {
var canvasX, canvasY,
textY,
scaling = 20,
textColour = "white",
backgroundColour = "rgba(0,0,0,0)",
canvas = this.textureCanvas,
ctx = canvas.getContext("2d"),
i, textHeight = 0, textHeights = [], width, widths = [], 
offsetx, offsety = 0, line, lines = [], offsetsx = [],
offsetsy = [], lineoffsetsy = [], fontStrings = [],
maxTexSize = this.getMaxTexSize(),
getFontString = function(i) {
textHeights[i] = scaling*cex[i];
var fontString = textHeights[i] + "px",
family0 = family[i],
font0 = font[i];
if (family0 === "sans")
family0 = "sans-serif";
else if (family0 === "mono")
family0 = "monospace";
fontString = fontString + " " + family0;
if (font0 === 2 || font0 === 4)
fontString = "bold " + fontString;
if (font0 === 3 || font0 === 4)
fontString = "italic " + fontString;
return fontString;
};
cex = this.repeatToLen(cex, text.length);
family = this.repeatToLen(family, text.length);
font = this.repeatToLen(font, text.length);
canvasX = 1;
line = -1;
offsetx = maxTexSize;
for (i = 0; i < text.length; i++)  {
ctx.font = fontStrings[i] = getFontString(i);
width = widths[i] = ctx.measureText(text[i]).width;
if (offsetx + width > maxTexSize) {
line += 1;
offsety = lineoffsetsy[line] = offsety + 2*textHeight;
if (offsety > maxTexSize)
console.error("Too many strings for texture.");
textHeight = 0;
offsetx = 0;
}
textHeight = Math.max(textHeight, textHeights[i]);
offsetsx[i] = offsetx;
offsetx += width;
canvasX = Math.max(canvasX, offsetx);
lines[i] = line;
}
offsety = lineoffsetsy[line] = offsety + 2*textHeight;
for (i = 0; i < text.length; i++) {
offsetsy[i] = lineoffsetsy[lines[i]];
}
canvasX = this.getPowerOfTwo(canvasX);
canvasY = this.getPowerOfTwo(offsety);
canvas.width = canvasX;
canvas.height = canvasY;
ctx.fillStyle = backgroundColour;
ctx.fillRect(0, 0, ctx.canvas.width, ctx.canvas.height);
ctx.textBaseline = "alphabetic";
for(i = 0; i < text.length; i++) {
ctx.font = fontStrings[i];
ctx.fillStyle = textColour;
ctx.textAlign = "left";
ctx.fillText(text[i], offsetsx[i],  offsetsy[i]);
}
return {canvasX:canvasX, canvasY:canvasY,
widths:widths, textHeights:textHeights,
offsetsx:offsetsx, offsetsy:offsetsy};
};
/**
* Set the gl viewport and scissor test
* @param { number } id - id of subscene
*/
rglwidgetClass.prototype.setViewport = function(id) {
var gl = this.gl || this.initGL(),
vp = this.getObj(id).par3d.viewport,
x = vp.x*this.canvas.width,
y = vp.y*this.canvas.height,
width = vp.width*this.canvas.width,
height = vp.height*this.canvas.height;
this.vp = {x:x, y:y, width:width, height:height};
gl.viewport(x, y, width, height);
gl.scissor(x, y, width, height);
gl.enable(gl.SCISSOR_TEST);
};
/**
* Set the projection matrix for a subscene
* @param { number } id - id of subscene
*/
rglwidgetClass.prototype.setprMatrix = function(id) {
var subscene = this.getObj(id),
embedding = subscene.embeddings.projection;
if (embedding === "replace")
this.prMatrix.makeIdentity();
else
this.setprMatrix(subscene.parent);
if (embedding === "inherit")
return;
// This is based on the Frustum::enclose code from geom.cpp
var bbox = subscene.par3d.bbox,
scale = subscene.par3d.scale,
ranges = [(bbox[1]-bbox[0])*scale[0]/2,
(bbox[3]-bbox[2])*scale[1]/2,
(bbox[5]-bbox[4])*scale[2]/2],
radius = Math.sqrt(this.sumsq(ranges))*1.1; // A bit bigger to handle labels
if (radius <= 0) radius = 1;
var observer = subscene.par3d.observer,
distance = observer[2],
FOV = subscene.par3d.FOV, ortho = FOV === 0,
t = ortho ? 1 : Math.tan(FOV*Math.PI/360),
near = distance - radius,
far = distance + radius,
hlen,
aspect = this.vp.width/this.vp.height,
z = subscene.par3d.zoom,
userProjection = subscene.par3d.userProjection;
if (far < 0.0)
far = 1.0;
if (near < far/100.0)
near = far/100.0;
hlen = t*near;
if (ortho) {
if (aspect > 1)
this.prMatrix.ortho(-hlen*aspect*z, hlen*aspect*z,
-hlen*z, hlen*z, near, far);
else
this.prMatrix.ortho(-hlen*z, hlen*z,
-hlen*z/aspect, hlen*z/aspect,
near, far);
} else {
if (aspect > 1)
this.prMatrix.frustum(-hlen*aspect*z, hlen*aspect*z,
-hlen*z, hlen*z, near, far);
else
this.prMatrix.frustum(-hlen*z, hlen*z,
-hlen*z/aspect, hlen*z/aspect,
near, far);
}
this.prMatrix.multRight(userProjection);
};
/**
* Set the model-view matrix for a subscene
* @param { number } id - id of the subscene
*/
rglwidgetClass.prototype.setmvMatrix = function(id) {
var observer = this.getObj(id).par3d.observer;
this.mvMatrix.makeIdentity();
this.setmodelMatrix(id);
this.mvMatrix.translate(-observer[0], -observer[1], -observer[2]);
};
/**
* Set the model matrix for a subscene
* @param { number } id - id of the subscene
*/
rglwidgetClass.prototype.setmodelMatrix = function(id) {
var subscene = this.getObj(id),
embedding = subscene.embeddings.model;
if (embedding !== "inherit") {
var scale = subscene.par3d.scale,
bbox = subscene.par3d.bbox,
center = [(bbox[0]+bbox[1])/2,
(bbox[2]+bbox[3])/2,
(bbox[4]+bbox[5])/2];
this.mvMatrix.translate(-center[0], -center[1], -center[2]);
this.mvMatrix.scale(scale[0], scale[1], scale[2]);
this.mvMatrix.multRight( subscene.par3d.userMatrix );
}
if (embedding !== "replace")
this.setmodelMatrix(subscene.parent);
};
/**
* Set the normals matrix for a subscene
* @param { number } subsceneid - id of the subscene
*/
rglwidgetClass.prototype.setnormMatrix = function(subsceneid) {
var self = this,
recurse = function(id) {
var sub = self.getObj(id),
embedding = sub.embeddings.model;
if (embedding !== "inherit") {
var scale = sub.par3d.scale;
self.normMatrix.scale(1/scale[0], 1/scale[1], 1/scale[2]);
self.normMatrix.multRight(sub.par3d.userMatrix);
}
if (embedding !== "replace")
recurse(sub.parent);
};
self.normMatrix.makeIdentity();
recurse(subsceneid);
};
/**
* Set the combined projection-model-view matrix
*/
rglwidgetClass.prototype.setprmvMatrix = function() {
this.prmvMatrix = new CanvasMatrix4( this.mvMatrix );
this.prmvMatrix.multRight( this.prMatrix );
};
/**
* Count clipping planes in a scene
* @returns {number}
*/
rglwidgetClass.prototype.countClipplanes = function() {
return this.countObjs("clipplanes");
};
/**
* Count lights in a scene
* @returns { number }
*/
rglwidgetClass.prototype.countLights = function() {
return this.countObjs("light");
};
/**
* Count objects of specific type in a scene
* @returns { number }
* @param { string } type - Type of object to count
*/
rglwidgetClass.prototype.countObjs = function(type) {
var self = this,
bound = 0;
Object.keys(this.scene.objects).forEach(
function(key) {
if (self.getObj(parseInt(key, 10)).type === type)
bound = bound + 1;
});
return bound;
};
/**
* Initialize a subscene
* @param { number } id - id of subscene.
*/
rglwidgetClass.prototype.initSubscene = function(id) {
var sub = this.getObj(id),
i, obj;
if (sub.type !== "subscene")
return;
sub.par3d.userMatrix = this.toCanvasMatrix4(sub.par3d.userMatrix);
sub.par3d.userProjection = this.toCanvasMatrix4(sub.par3d.userProjection);
sub.par3d.userProjection.transpose();
sub.par3d.listeners = [].concat(sub.par3d.listeners);
sub.backgroundId = undefined;
sub.subscenes = [];
sub.clipplanes = [];
sub.transparent = [];
sub.opaque = [];
sub.lights = [];
for (i=0; i < sub.objects.length; i++) {
obj = this.getObj(sub.objects[i]);
if (typeof obj === "undefined") {
sub.objects.splice(i, 1);
i--;
} else if (obj.type === "background")
sub.backgroundId = obj.id;
else
sub[this.whichList(obj.id)].push(obj.id);
}
};
/**
* Copy object
* @param { number } id - id of object to copy
* @param { string } reuse - Document id of scene to reuse
*/
rglwidgetClass.prototype.copyObj = function(id, reuse) {
var obj = this.getObj(id),
prev = document.getElementById(reuse);
if (prev !== null) {
prev = prev.rglinstance;
var
prevobj = prev.getObj(id),
fields = ["flags", "type",
"colors", "vertices", "centers",
"normals", "offsets",
"texts", "cex", "family", "font", "adj",
"material",
"radii",
"texcoords",
"userMatrix", "ids",
"dim",
"par3d", "userMatrix",
"viewpoint", "finite",
"pos"],
i;
for (i = 0; i < fields.length; i++) {
if (typeof prevobj[fields[i]] !== "undefined")
obj[fields[i]] = prevobj[fields[i]];
}
} else
console.warn("copyObj failed");
};
/**
* Update the triangles used to display a plane
* @param { number } id - id of the plane
* @param { Object } bbox - bounding box in which to display the plane
*/
rglwidgetClass.prototype.planeUpdateTriangles = function(id, bbox) {
var perms = [[0,0,1], [1,2,2], [2,1,0]],
x, xrow, elem, A, d, nhits, i, j, k, u, v, w, intersect, which, v0, v2, vx, reverse,
face1 = [], face2 = [], normals = [],
obj = this.getObj(id),
nPlanes = obj.normals.length;
obj.bbox = bbox;
obj.vertices = [];
obj.initialized = false;
for (elem = 0; elem < nPlanes; elem++) {
//    Vertex Av = normal.getRecycled(elem);
x = [];
A = obj.normals[elem];
d = obj.offsets[elem][0];
nhits = 0;
for (i=0; i<3; i++)
for (j=0; j<2; j++)
for (k=0; k<2; k++) {
u = perms[0][i];
v = perms[1][i];
w = perms[2][i];
if (A[w] !== 0.0) {
intersect = -(d + A[u]*bbox[j+2*u] + A[v]*bbox[k+2*v])/A[w];
if (bbox[2*w] < intersect && intersect < bbox[1+2*w]) {
xrow = [];
xrow[u] = bbox[j+2*u];
xrow[v] = bbox[k+2*v];
xrow[w] = intersect;
x.push(xrow);
face1[nhits] = j + 2*u;
face2[nhits] = k + 2*v;
nhits++;
}
}
}
if (nhits > 3) {
/* Re-order the intersections so the triangles work */
for (i=0; i<nhits-2; i++) {
which = 0; /* initialize to suppress warning */
for (j=i+1; j<nhits; j++) {
if (face1[i] == face1[j] || face1[i] == face2[j] ||
face2[i] == face1[j] || face2[i] == face2[j] ) {
which = j;
break;
}
}
if (which > i+1) {
this.swap(x, i+1, which);
this.swap(face1, i+1, which);
this.swap(face2, i+1, which);
}
}
}
if (nhits >= 3) {
/* Put in order so that the normal points out the FRONT of the faces */
v0 = [x[0][0] - x[1][0] , x[0][1] - x[1][1], x[0][2] - x[1][2]];
v2 = [x[2][0] - x[1][0] , x[2][1] - x[1][1], x[2][2] - x[1][2]];
/* cross-product */
vx = this.xprod(v0, v2);
reverse = this.dotprod(vx, A) > 0;
for (i=0; i<nhits-2; i++) {
obj.vertices.push(x[0]);
normals.push(A);
for (j=1; j<3; j++) {
obj.vertices.push(x[i + (reverse ? 3-j : j)]);
normals.push(A);
}
}
}
}
obj.pnormals = normals;
};
rglwidgetClass.prototype.getAdj = function (pos, offset, text) {
switch(pos) {
case 1: return [0.5, 1 + offset];
case 2: return [1 + offset/text.length, 0.5];
case 3: return [0.5, -offset];
case 4: return [-offset/text.length, 0.5];
}
}
/**
* Initialize object for display
* @param { number } id - id of object to initialize
*/
rglwidgetClass.prototype.initObj = function(id) {
var obj = this.getObj(id),
flags = obj.flags,
type = obj.type,
is_lit = flags & this.f_is_lit,
is_lines = flags & this.f_is_lines,
fat_lines = flags & this.f_fat_lines,
has_texture = flags & this.f_has_texture,
fixed_quads = flags & this.f_fixed_quads,
is_transparent = obj.is_transparent,
depth_sort = flags & this.f_depth_sort,
sprites_3d = flags & this.f_sprites_3d,
sprite_3d = flags & this.f_sprite_3d,
fixed_size = flags & this.f_fixed_size,
is_twosided = (flags & this.f_is_twosided) > 0,
is_brush = flags & this.f_is_brush,
gl = this.gl || this.initGL(),
polygon_offset,
texinfo, drawtype, nclipplanes, f, nrows, oldrows,
i,j,v,v1,v2, mat, uri, matobj, pass, passes, pmode,
dim, nx, nz, attr;
if (typeof id !== "number") {
this.alertOnce("initObj id is "+typeof id);
}
obj.initialized = true;
if (type === "bboxdeco" || type === "subscene")
return;
if (type === "light") {
obj.ambient = new Float32Array(obj.colors[0].slice(0,3));
obj.diffuse = new Float32Array(obj.colors[1].slice(0,3));
obj.specular = new Float32Array(obj.colors[2].slice(0,3));
obj.lightDir = new Float32Array(obj.vertices[0]);
return;
}
if (type === "clipplanes") {
obj.vClipplane = this.flatten(this.cbind(obj.normals, obj.offsets));
return;
}
if (type === "background" && typeof obj.ids !== "undefined") {
obj.quad = this.flatten([].concat(obj.ids));
return;
}
polygon_offset = this.getMaterial(id, "polygon_offset");
if (polygon_offset[0] != 0 || polygon_offset[1] != 0)
obj.polygon_offset = polygon_offset;
if (is_transparent) {
depth_sort = ["triangles", "quads", "surface",
"spheres", "sprites", "text"].indexOf(type) >= 0;
}
if (is_brush)
this.initSelection(id);
if (typeof obj.vertices === "undefined")
obj.vertices = [];
v = obj.vertices;
obj.vertexCount = v.length;
if (!obj.vertexCount) return;
if (is_twosided) {
if (typeof obj.userAttributes === "undefined")
obj.userAttributes = {};
v1 = Array(v.length);
v2 = Array(v.length);
if (obj.type == "triangles" || obj.type == "quads") {
if (obj.type == "triangles")
nrow = 3;
else
nrow = 4;
for (i=0; i<Math.floor(v.length/nrow); i++)
for (j=0; j<nrow; j++) {
v1[nrow*i + j] = v[nrow*i + ((j+1) % nrow)];
v2[nrow*i + j] = v[nrow*i + ((j+2) % nrow)];
}
} else if (obj.type == "surface") {
dim = obj.dim[0];
nx = dim[0];
nz = dim[1];
for (j=0; j<nx; j++) {
for (i=0; i<nz; i++) {
if (i+1 < nz && j+1 < nx) {
v2[j + nx*i] = v[j + nx*(i+1)];
v1[j + nx*i] = v[j+1 + nx*(i+1)];
} else if (i+1 < nz) {
v2[j + nx*i] = v[j-1 + nx*i];
v1[j + nx*i] = v[j + nx*(i+1)];
} else {
v2[j + nx*i] = v[j + nx*(i-1)];
v1[j + nx*i] = v[j-1 + nx*(i-1)];
}
}
}
}
obj.userAttributes.aPos1 = v1;
obj.userAttributes.aPos2 = v2;
}
if (!sprites_3d) {
if (gl.isContextLost()) return;
obj.prog = gl.createProgram();
gl.attachShader(obj.prog, this.getShader( gl.VERTEX_SHADER,
this.getVertexShader(id) ));
gl.attachShader(obj.prog, this.getShader( gl.FRAGMENT_SHADER,
this.getFragmentShader(id) ));
//  Force aPos to location 0, aCol to location 1
gl.bindAttribLocation(obj.prog, 0, "aPos");
gl.bindAttribLocation(obj.prog, 1, "aCol");
gl.linkProgram(obj.prog);
var linked = gl.getProgramParameter(obj.prog, gl.LINK_STATUS);
if (!linked) {
// An error occurred while linking
var lastError = gl.getProgramInfoLog(obj.prog);
console.warn("Error in program linking:" + lastError);
gl.deleteProgram(obj.prog);
return;
}
}
if (type === "text") {
texinfo = this.drawTextToCanvas(obj.texts,
this.flatten(obj.cex),
this.flatten(obj.family),
this.flatten(obj.family));
}
if (fixed_quads && !sprites_3d) {
obj.ofsLoc = gl.getAttribLocation(obj.prog, "aOfs");
}
if (sprite_3d) {
obj.origLoc = gl.getUniformLocation(obj.prog, "uOrig");
obj.sizeLoc = gl.getUniformLocation(obj.prog, "uSize");
obj.usermatLoc = gl.getUniformLocation(obj.prog, "usermat");
}
if (has_texture || type == "text") {
if (!obj.texture)
obj.texture = gl.createTexture();
obj.texLoc = gl.getAttribLocation(obj.prog, "aTexcoord");
obj.sampler = gl.getUniformLocation(obj.prog, "uSampler");
}
if (has_texture) {
mat = obj.material;
if (typeof mat.uri !== "undefined")
uri = mat.uri;
else if (typeof mat.uriElementId === "undefined") {
matobj = this.getObj(mat.uriId);
if (typeof matobj !== "undefined") {
uri = matobj.material.uri;
} else {
uri = "";
}
} else
uri = document.getElementById(mat.uriElementId).rglinstance.getObj(mat.uriId).material.uri;
this.loadImageToTexture(uri, obj.texture);
}
if (type === "text") {
this.handleLoadedTexture(obj.texture, this.textureCanvas);
}
var stride = 3, nc, cofs, nofs, radofs, oofs, tofs, vnew, fnew,
nextofs = -1, pointofs = -1, alias, colors, key, selection, filter, adj, pos, offset;
obj.alias = undefined;
colors = obj.colors;
j = this.scene.crosstalk.id.indexOf(id);
if (j >= 0) {
key = this.scene.crosstalk.key[j];
options = this.scene.crosstalk.options[j];
colors = colors.slice(0); 
for (i = 0; i < v.length; i++)
colors[i] = obj.colors[i % obj.colors.length].slice(0);
if ( (selection = this.scene.crosstalk.selection) &&
(selection.length || !options.selectedIgnoreNone) )
for (i = 0; i < v.length; i++) {
if (!selection.includes(key[i])) {
if (options.deselectedColor)
colors[i] = options.deselectedColor.slice(0);
colors[i][3] = colors[i][3]*options.deselectedFade;   /* default: mostly transparent if not selected */
} else if (options.selectedColor)
colors[i] = options.selectedColor.slice(0);
}
if ( (filter = this.scene.crosstalk.filter) )
for (i = 0; i < v.length; i++) 
if (!filter.includes(key[i])) {
if (options.filteredColor)
colors[i] = options.filteredColor.slice(0);
colors[i][3] = colors[i][3]*options.filteredFade;   /* default: completely hidden if filtered */
}
}  
nc = obj.colorCount = colors.length;
if (nc > 1) {
cofs = stride;
stride = stride + 4;
v = this.cbind(v, colors);
} else {
cofs = -1;
obj.onecolor = this.flatten(colors);
}
if (typeof obj.normals !== "undefined") {
nofs = stride;
stride = stride + 3;
v = this.cbind(v, typeof obj.pnormals !== "undefined" ? obj.pnormals : obj.normals);
} else
nofs = -1;
if (typeof obj.radii !== "undefined") {
radofs = stride;
stride = stride + 1;
// FIXME:  always concat the radii?
if (obj.radii.length === v.length) {
v = this.cbind(v, obj.radii);
} else if (obj.radii.length === 1) {
v = v.map(function(row, i, arr) { return row.concat(obj.radii[0]);});
}
} else
radofs = -1;
// Add default indices
f = Array(v.length);
for (i = 0; i < v.length; i++)
f[i] = i;
obj.f = [f,f];
if (type == "sprites" && !sprites_3d) {
tofs = stride;
stride += 2;
oofs = stride;
stride += 2;
vnew = new Array(4*v.length);
fnew = new Array(4*v.length);
alias = new Array(v.length);
var rescale = fixed_size ? 72 : 1,
size = obj.radii, s = rescale*size[0]/2;
last = v.length;
f = obj.f[0];
for (i=0; i < v.length; i++) {
if (size.length > 1)
s = rescale*size[i]/2;
vnew[i]  = v[i].concat([0,0,-s,-s]);
fnew[4*i] = f[i];
vnew[last]= v[i].concat([1,0, s,-s]);
fnew[4*i+1] = last++;
vnew[last]= v[i].concat([1,1, s, s]);
fnew[4*i+2] = last++;
vnew[last]= v[i].concat([0,1,-s, s]);
fnew[4*i+3] = last++;
alias[i] = [last-3, last-2, last-1];
}
v = vnew;
obj.vertexCount = v.length;
obj.f = [fnew, fnew];
} else if (type === "text") {
tofs = stride;
stride += 2;
oofs = stride;
stride += 2;
vnew = new Array(4*v.length);
f = obj.f[0];
fnew = new Array(4*f.length);
alias = new Array(v.length);
last = v.length;
adj = this.flatten(obj.adj);
if (typeof obj.pos !== "undefined") {
pos = this.flatten(obj.pos);
offset = adj[0];
}
for (i=0; i < v.length; i++) {
if (typeof pos !== "undefined")
adj = this.getAdj(pos[i % pos.length], offset, obj.texts[i]);
vnew[i]  = v[i].concat([0,-0.5]).concat(adj);
fnew[4*i] = f[i];
vnew[last] = v[i].concat([1,-0.5]).concat(adj);
fnew[4*i+1] = last++;
vnew[last] = v[i].concat([1, 1.5]).concat(adj);
fnew[4*i+2] = last++;
vnew[last] = v[i].concat([0, 1.5]).concat(adj);
fnew[4*i+3] = last++;
alias[i] = [last-3, last-2, last-1];
for (j=0; j < 4; j++) {
v1 = vnew[fnew[4*i+j]];
v1[tofs+2] = 2*(v1[tofs]-v1[tofs+2])*texinfo.widths[i];
v1[tofs+3] = 2*(v1[tofs+1]-v1[tofs+3])*texinfo.textHeights[i];
v1[tofs] = (texinfo.offsetsx[i] + v1[tofs]*texinfo.widths[i])/texinfo.canvasX;
v1[tofs+1] = 1.0-(texinfo.offsetsy[i] -
v1[tofs+1]*texinfo.textHeights[i])/texinfo.canvasY;
vnew[fnew[4*i+j]] = v1;
}
}
v = vnew;
obj.vertexCount = v.length;
obj.f = [fnew, fnew];
} else if (typeof obj.texcoords !== "undefined") {
tofs = stride;
stride += 2;
oofs = -1;
v = this.cbind(v, obj.texcoords);
} else {
tofs = -1;
oofs = -1;
}
obj.alias = alias;
if (typeof obj.userAttributes !== "undefined") {
obj.userAttribOffsets = {};
obj.userAttribLocations = {};
obj.userAttribSizes = {};
for (attr in obj.userAttributes) {
obj.userAttribLocations[attr] = gl.getAttribLocation(obj.prog, attr);
if (obj.userAttribLocations[attr] >= 0) { // Attribute may not have been used
obj.userAttribOffsets[attr] = stride;
v = this.cbind(v, obj.userAttributes[attr]);
stride = v[0].length;
obj.userAttribSizes[attr] = stride - obj.userAttribOffsets[attr];
}
}
}
if (typeof obj.userUniforms !== "undefined") {
obj.userUniformLocations = {};
for (attr in obj.userUniforms)
obj.userUniformLocations[attr] = gl.getUniformLocation(obj.prog, attr);
}
if (sprites_3d) {
obj.userMatrix = new CanvasMatrix4(obj.userMatrix);
obj.objects = this.flatten([].concat(obj.ids));
is_lit = false;
for (i=0; i < obj.objects.length; i++)
this.initObj(obj.objects[i]);
}
if (is_lit && !fixed_quads) {
obj.normLoc = gl.getAttribLocation(obj.prog, "aNorm");
}
nclipplanes = this.countClipplanes();
if (nclipplanes && !sprites_3d) {
obj.clipLoc = [];
for (i=0; i < nclipplanes; i++)
obj.clipLoc[i] = gl.getUniformLocation(obj.prog,"vClipplane" + i);
}
if (is_lit) {
obj.emissionLoc = gl.getUniformLocation(obj.prog, "emission");
obj.emission = new Float32Array(this.stringToRgb(this.getMaterial(id, "emission")));
obj.shininessLoc = gl.getUniformLocation(obj.prog, "shininess");
obj.shininess = this.getMaterial(id, "shininess");
obj.nlights = this.countLights();
obj.ambientLoc = [];
obj.ambient = new Float32Array(this.stringToRgb(this.getMaterial(id, "ambient")));
obj.specularLoc = [];
obj.specular = new Float32Array(this.stringToRgb(this.getMaterial(id, "specular")));
obj.diffuseLoc = [];
obj.lightDirLoc = [];
obj.viewpointLoc = [];
obj.finiteLoc = [];
for (i=0; i < obj.nlights; i++) {
obj.ambientLoc[i] = gl.getUniformLocation(obj.prog, "ambient" + i);
obj.specularLoc[i] = gl.getUniformLocation(obj.prog, "specular" + i);
obj.diffuseLoc[i] = gl.getUniformLocation(obj.prog, "diffuse" + i);
obj.lightDirLoc[i] = gl.getUniformLocation(obj.prog, "lightDir" + i);
obj.viewpointLoc[i] = gl.getUniformLocation(obj.prog, "viewpoint" + i);
obj.finiteLoc[i] = gl.getUniformLocation(obj.prog, "finite" + i);
}
}
obj.passes = is_twosided + 1;
obj.pmode = new Array(obj.passes);
for (pass = 0; pass < obj.passes; pass++) {
if (type === "triangles" || type === "quads" || type === "surface")
pmode = this.getMaterial(id, (pass === 0) ? "front" : "back");
else pmode = "filled";
obj.pmode[pass] = pmode;
}
obj.f.length = obj.passes;
for (pass = 0; pass < obj.passes; pass++) {
f = fnew = obj.f[pass];
pmode = obj.pmode[pass];
if (pmode === "culled")
f = [];
else if (pmode === "points") {
// stay with default
} else if ((type === "quads" || type === "text" ||
type === "sprites") && !sprites_3d) {
nrows = Math.floor(obj.vertexCount/4);
if (pmode === "filled") {
fnew = Array(6*nrows);
for (i=0; i < nrows; i++) {
fnew[6*i] = f[4*i];
fnew[6*i+1] = f[4*i + 1];
fnew[6*i+2] = f[4*i + 2];
fnew[6*i+3] = f[4*i];
fnew[6*i+4] = f[4*i + 2];
fnew[6*i+5] = f[4*i + 3];
}
} else {
fnew = Array(8*nrows);
for (i=0; i < nrows; i++) {
fnew[8*i] = f[4*i];
fnew[8*i+1] = f[4*i + 1];
fnew[8*i+2] = f[4*i + 1];
fnew[8*i+3] = f[4*i + 2];
fnew[8*i+4] = f[4*i + 2];
fnew[8*i+5] = f[4*i + 3];
fnew[8*i+6] = f[4*i + 3];
fnew[8*i+7] = f[4*i];
}
}
} else if (type === "triangles") {
nrows = Math.floor(obj.vertexCount/3);
if (pmode === "filled") {
fnew = Array(3*nrows);
for (i=0; i < fnew.length; i++) {
fnew[i] = f[i];
}
} else if (pmode === "lines") {
fnew = Array(6*nrows);
for (i=0; i < nrows; i++) {
fnew[6*i] = f[3*i];
fnew[6*i + 1] = f[3*i + 1];
fnew[6*i + 2] = f[3*i + 1];
fnew[6*i + 3] = f[3*i + 2];
fnew[6*i + 4] = f[3*i + 2];
fnew[6*i + 5] = f[3*i];
}
}
} else if (type === "spheres") {
// default
} else if (type === "surface") {
dim = obj.dim[0];
nx = dim[0];
nz = dim[1];
if (pmode === "filled") {
fnew = [];
for (j=0; j<nx-1; j++) {
for (i=0; i<nz-1; i++) {
fnew.push(f[j + nx*i],
f[j + nx*(i+1)],
f[j + 1 + nx*(i+1)],
f[j + nx*i],
f[j + 1 + nx*(i+1)],
f[j + 1 + nx*i]);
}
}
} else if (pmode === "lines") {
fnew = [];
for (j=0; j<nx; j++) {
for (i=0; i<nz; i++) {
if (i+1 < nz)
fnew.push(f[j + nx*i],
f[j + nx*(i+1)]);
if (j+1 < nx)
fnew.push(f[j + nx*i],
f[j+1 + nx*i]);
}
}
}
}
obj.f[pass] = fnew;
if (depth_sort) {
drawtype = "DYNAMIC_DRAW";
} else {
drawtype = "STATIC_DRAW";
}
}
if (fat_lines) {
alias = undefined;
obj.nextLoc = gl.getAttribLocation(obj.prog, "aNext");
obj.pointLoc = gl.getAttribLocation(obj.prog, "aPoint");
obj.aspectLoc = gl.getUniformLocation(obj.prog, "uAspect");
obj.lwdLoc = gl.getUniformLocation(obj.prog, "uLwd");
// Expand vertices to turn each segment into a pair of triangles
for (pass = 0; pass < obj.passes; pass++) {
f = obj.f[pass];    
oldrows = f.length;
if (obj.pmode[pass] === "lines") 
break;
}
if (type === "linestrip") 
nrows = 4*(oldrows - 1); 
else
nrows = 2*oldrows;
vnew = new Array(nrows);
fnew = new Array(1.5*nrows);
var fnext = new Array(nrows),
fpt = new Array(nrows), 
pt, start, gap = type === "linestrip" ? 3 : 1;
// We're going to turn each pair of vertices into 4 new ones, with the "next" and "pt" attributes
// added.
// We do this by copying the originals in the first pass, adding the new attributes, then in a 
// second pass add new vertices at the end.
for (i = 0; i < v.length; i++) {
vnew[i] = v[i].concat([0,0,0,0,0]); 
}
nextofs = stride;
pointofs = stride + 3;
stride = stride + 5;
// Now add the extras
last = v.length - 1;
ind = 0;
alias = new Array(f.length);
for (i = 0; i < f.length; i++)
alias[i] = [];
for (i = 0; i < f.length - 1; i++) {
if (type !== "linestrip" && i % 2 == 1)
continue;
k = ++last;
vnew[k] = vnew[f[i]].slice();
for (j=0; j<3; j++)
vnew[k][nextofs + j] = vnew[f[i+1]][j];
vnew[k][pointofs] = -1;
vnew[k][pointofs+1] = -1;
fnew[ind] = k;
last++;
vnew[last] = vnew[k].slice();
vnew[last][pointofs] = 1;
fnew[ind+1] = last;
alias[f[i]].push(last-1, last);
last++;
k = last;
vnew[k] = vnew[f[i+1]].slice();
for (j=0; j<3; j++)
vnew[k][nextofs + j] = vnew[f[i]][j];
vnew[k][pointofs] = -1;
vnew[k][pointofs+1] = 1;
fnew[ind+2] = k;
fnew[ind+3] = fnew[ind+1];
last++;
vnew[last] = vnew[k].slice();
vnew[last][pointofs] = 1;
fnew[ind+4] = last;
fnew[ind+5] = fnew[ind+2];
ind += 6;
alias[f[i+1]].push(last-1, last);
}
vnew.length = last+1;
v = vnew;
obj.vertexCount = v.length;
if (typeof alias !== "undefined" && typeof obj.alias !== "undefined") {  // Already have aliases from previous section?
var oldalias = obj.alias, newalias = Array(obj.alias.length);
for (i = 0; i < newalias.length; i++) {
newalias[i] = oldalias[i].slice();
for (j = 0; j < oldalias[i].length; j++)
Array.prototype.push.apply(newalias[i], alias[oldalias[j]]); // pushes each element 
}
obj.alias = newalias;
} else
obj.alias = alias;
for (pass = 0; pass < obj.passes; pass++)
if (type === "lines" || type === "linestrip" || obj.pmode[pass] == "lines") {
obj.f[pass] = fnew;
}
if (depth_sort) 
drawtype = "DYNAMIC_DRAW";
else
drawtype = "STATIC_DRAW";
}
for (pass = 0; pass < obj.passes; pass++) {
if (obj.vertexCount > 65535) {
if (this.index_uint) {
obj.f[pass] = new Uint32Array(obj.f[pass]);
obj.index_uint = true;
} else
this.alertOnce("Object has "+obj.vertexCount+" vertices, not supported in this browser.");
} else {
obj.f[pass] = new Uint16Array(obj.f[pass]);
obj.index_uint = false;
}
}
if (stride !== v[0].length) {
this.alertOnce("problem in stride calculation");
}
obj.vOffsets = {vofs:0, cofs:cofs, nofs:nofs, radofs:radofs, oofs:oofs, tofs:tofs,
nextofs:nextofs, pointofs:pointofs, stride:stride};
obj.values = new Float32Array(this.flatten(v));
if (type !== "spheres" && !sprites_3d) {
obj.buf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, obj.buf);
gl.bufferData(gl.ARRAY_BUFFER, obj.values, gl.STATIC_DRAW); //
obj.ibuf = Array(obj.passes);
obj.ibuf[0] = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, obj.ibuf[0]);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, obj.f[0], gl[drawtype]);
if (is_twosided) {
obj.ibuf[1] = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, obj.ibuf[1]);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, obj.f[1], gl[drawtype]);
}
}
if (!sprites_3d) {
obj.mvMatLoc = gl.getUniformLocation(obj.prog, "mvMatrix");
obj.prMatLoc = gl.getUniformLocation(obj.prog, "prMatrix");
}
if (fixed_size) {
obj.textScaleLoc = gl.getUniformLocation(obj.prog, "textScale");
}
if (is_lit && !sprites_3d) {
obj.normMatLoc = gl.getUniformLocation(obj.prog, "normMatrix");
}
if (is_twosided) {
obj.frontLoc = gl.getUniformLocation(obj.prog, "front");
}
};
/**
* Set gl depth test based on object's material
* @param { number } id - object to use
*/
rglwidgetClass.prototype.setDepthTest = function(id) {
var gl = this.gl || this.initGL(),
tests = {never: gl.NEVER,
less:  gl.LESS,
equal: gl.EQUAL,
lequal:gl.LEQUAL,
greater: gl.GREATER,
notequal: gl.NOTEQUAL,
gequal: gl.GEQUAL,
always: gl.ALWAYS},
test = tests[this.getMaterial(id, "depth_test")];
gl.depthFunc(test);
};
rglwidgetClass.prototype.mode4type = {points : "POINTS",
linestrip : "LINE_STRIP",
abclines : "LINES",
lines : "LINES",
sprites : "TRIANGLES",
planes : "TRIANGLES",
text : "TRIANGLES",
quads : "TRIANGLES",
surface : "TRIANGLES",
triangles : "TRIANGLES"};
/**
* Sort objects from back to front
* @returns { number[] }
* @param { Object } obj - object to sort
*/
rglwidgetClass.prototype.depthSort = function(obj) {
var n = obj.centers.length,
depths = new Float32Array(n),
result = new Array(n),
compare = function(i,j) { return depths[j] - depths[i]; },
z, w;
for(i=0; i<n; i++) {
z = this.prmvMatrix.m13*obj.centers[i][0] +
this.prmvMatrix.m23*obj.centers[i][1] +
this.prmvMatrix.m33*obj.centers[i][2] +
this.prmvMatrix.m43;
w = this.prmvMatrix.m14*obj.centers[i][0] +
this.prmvMatrix.m24*obj.centers[i][1] +
this.prmvMatrix.m34*obj.centers[i][2] +
this.prmvMatrix.m44;
depths[i] = z/w;
result[i] = i;
}
result.sort(compare);
return result;
};
rglwidgetClass.prototype.disableArrays = function(obj, enabled) {
var gl = this.gl || this.initGL(),
objLocs = ["normLoc", "texLoc", "ofsLoc", "pointLoc", "nextLoc"],
thisLocs = ["posLoc", "colLoc"], i, attr;
for (i = 0; i < objLocs.length; i++) 
if (enabled[objLocs[i]]) gl.disableVertexAttribArray(obj[objLocs[i]]);
for (i = 0; i < thisLocs.length; i++)
if (enabled[thisLocs[i]]) gl.disableVertexAttribArray(this[objLocs[i]]);
if (typeof obj.userAttributes !== "undefined") {
for (attr in obj.userAttribSizes) {  // Not all attributes may have been used
gl.disableVertexAttribArray( obj.userAttribLocations[attr] );
}
}
}
/**
* Draw an object in a subscene
* @param { number } id - object to draw
* @param { number } subsceneid - id of subscene
*/
rglwidgetClass.prototype.drawObj = function(id, subsceneid) {
var obj = this.getObj(id),
subscene = this.getObj(subsceneid),
flags = obj.flags,
type = obj.type,
is_lit = flags & this.f_is_lit,
has_texture = flags & this.f_has_texture,
fixed_quads = flags & this.f_fixed_quads,
is_transparent = flags & this.f_is_transparent,
depth_sort = flags & this.f_depth_sort,
sprites_3d = flags & this.f_sprites_3d,
sprite_3d = flags & this.f_sprite_3d,
is_lines = flags & this.f_is_lines,
fat_lines = flags & this.f_fat_lines,
is_points = flags & this.f_is_points,
fixed_size = flags & this.f_fixed_size,
is_twosided = (flags & this.f_is_twosided) > 0,
gl = this.gl || this.initGL(),
mat,
sphereMV, baseofs, ofs, sscale, i, count, light,
pass, mode, pmode, attr,
enabled = {};
if (typeof id !== "number") {
this.alertOnce("drawObj id is "+typeof id);
}
if (type === "planes") {
if (obj.bbox !== subscene.par3d.bbox || !obj.initialized) {
this.planeUpdateTriangles(id, subscene.par3d.bbox);
}
}
if (!obj.initialized)
this.initObj(id);
if (type === "clipplanes") {
count = obj.offsets.length;
var IMVClip = [];
for (i=0; i < count; i++) {
IMVClip[i] = this.multMV(this.invMatrix, obj.vClipplane.slice(4*i, 4*(i+1)));
}
obj.IMVClip = IMVClip;
return;
}
if (type === "light" || type === "bboxdeco" || !obj.vertexCount)
return;
if (!is_transparent &&
obj.someHidden) {
is_transparent = true;
depth_sort = ["triangles", "quads", "surface",
"spheres", "sprites", "text"].indexOf(type) >= 0;
}        
this.setDepthTest(id);
if (sprites_3d) {
var norigs = obj.vertices.length,
savenorm = new CanvasMatrix4(this.normMatrix);
this.origs = obj.vertices;
this.usermat = new Float32Array(obj.userMatrix.getAsArray());
this.radii = obj.radii;
this.normMatrix = subscene.spriteNormmat;
for (this.iOrig=0; this.iOrig < norigs; this.iOrig++) {
for (i=0; i < obj.objects.length; i++) {
this.drawObj(obj.objects[i], subsceneid);
}
}
this.normMatrix = savenorm;
return;
} else {
gl.useProgram(obj.prog);
}
if (typeof obj.polygon_offset !== "undefined") {
gl.polygonOffset(obj.polygon_offset[0],
obj.polygon_offset[1]);
gl.enable(gl.POLYGON_OFFSET_FILL);
}
if (sprite_3d) {
gl.uniform3fv(obj.origLoc, new Float32Array(this.origs[this.iOrig]));
if (this.radii.length > 1) {
gl.uniform1f(obj.sizeLoc, this.radii[this.iOrig][0]);
} else {
gl.uniform1f(obj.sizeLoc, this.radii[0][0]);
}
gl.uniformMatrix4fv(obj.usermatLoc, false, this.usermat);
}
if (type === "spheres") {
gl.bindBuffer(gl.ARRAY_BUFFER, this.sphere.buf);
} else {
gl.bindBuffer(gl.ARRAY_BUFFER, obj.buf);
}
gl.uniformMatrix4fv( obj.prMatLoc, false, new Float32Array(this.prMatrix.getAsArray()) );
gl.uniformMatrix4fv( obj.mvMatLoc, false, new Float32Array(this.mvMatrix.getAsArray()) );
var clipcheck = 0,
clipplaneids = subscene.clipplanes,
clip, j;
for (i=0; i < clipplaneids.length; i++) {
clip = this.getObj(clipplaneids[i]);
for (j=0; j < clip.offsets.length; j++) {
gl.uniform4fv(obj.clipLoc[clipcheck + j], clip.IMVClip[j]);
}
clipcheck += clip.offsets.length;
}
if (typeof obj.clipLoc !== "undefined")
for (i=clipcheck; i < obj.clipLoc.length; i++)
gl.uniform4f(obj.clipLoc[i], 0,0,0,0);
if (is_lit) {
gl.uniformMatrix4fv( obj.normMatLoc, false, new Float32Array(this.normMatrix.getAsArray()) );
gl.uniform3fv( obj.emissionLoc, obj.emission);
gl.uniform1f( obj.shininessLoc, obj.shininess);
for (i=0; i < subscene.lights.length; i++) {
light = this.getObj(subscene.lights[i]);
if (!light.initialized) this.initObj(subscene.lights[i]);
gl.uniform3fv( obj.ambientLoc[i], this.componentProduct(light.ambient, obj.ambient));
gl.uniform3fv( obj.specularLoc[i], this.componentProduct(light.specular, obj.specular));
gl.uniform3fv( obj.diffuseLoc[i], light.diffuse);
gl.uniform3fv( obj.lightDirLoc[i], light.lightDir);
gl.uniform1i( obj.viewpointLoc[i], light.viewpoint);
gl.uniform1i( obj.finiteLoc[i], light.finite);
}
for (i=subscene.lights.length; i < obj.nlights; i++) {
gl.uniform3f( obj.ambientLoc[i], 0,0,0);
gl.uniform3f( obj.specularLoc[i], 0,0,0);
gl.uniform3f( obj.diffuseLoc[i], 0,0,0);
}
}
if (fixed_size) {
gl.uniform2f( obj.textScaleLoc, 0.75/this.vp.width, 0.75/this.vp.height);
}
gl.enableVertexAttribArray( this.posLoc );
enabled.posLoc = true;
var nc = obj.colorCount;
count = obj.vertexCount;
if (type === "spheres") {
subscene = this.getObj(subsceneid);
var scale = subscene.par3d.scale,
scount = count, indices;
gl.vertexAttribPointer(this.posLoc,  3, gl.FLOAT, false, 4*this.sphere.vOffsets.stride,  0);
gl.enableVertexAttribArray(obj.normLoc );
enabled.normLoc = true;
gl.vertexAttribPointer(obj.normLoc,  3, gl.FLOAT, false, 4*this.sphere.vOffsets.stride,  0);
gl.disableVertexAttribArray( this.colLoc );
var sphereNorm = new CanvasMatrix4();
sphereNorm.scale(scale[0], scale[1], scale[2]);
sphereNorm.multRight(this.normMatrix);
gl.uniformMatrix4fv( obj.normMatLoc, false, new Float32Array(sphereNorm.getAsArray()) );
if (nc == 1) {
gl.vertexAttrib4fv( this.colLoc, new Float32Array(obj.onecolor));
}
if (has_texture) {
gl.enableVertexAttribArray( obj.texLoc );
enabled.texLoc = true;
gl.vertexAttribPointer(obj.texLoc, 2, gl.FLOAT, false, 4*this.sphere.vOffsets.stride,
4*this.sphere.vOffsets.tofs);
gl.activeTexture(gl.TEXTURE0);
gl.bindTexture(gl.TEXTURE_2D, obj.texture);
gl.uniform1i( obj.sampler, 0);
}
if (depth_sort)
indices = this.depthSort(obj);
for (i = 0; i < scount; i++) {
sphereMV = new CanvasMatrix4();
if (depth_sort) {
baseofs = indices[i]*obj.vOffsets.stride;
} else {
baseofs = i*obj.vOffsets.stride;
}
ofs = baseofs + obj.vOffsets.radofs;
sscale = obj.values[ofs];
sphereMV.scale(sscale/scale[0], sscale/scale[1], sscale/scale[2]);
sphereMV.translate(obj.values[baseofs],
obj.values[baseofs+1],
obj.values[baseofs+2]);
sphereMV.multRight(this.mvMatrix);
gl.uniformMatrix4fv( obj.mvMatLoc, false, new Float32Array(sphereMV.getAsArray()) );
if (nc > 1) {
ofs = baseofs + obj.vOffsets.cofs;
gl.vertexAttrib4f( this.colLoc, obj.values[ofs],
obj.values[ofs+1],
obj.values[ofs+2],
obj.values[ofs+3] );
}
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, this.sphere.ibuf);
gl.drawElements(gl.TRIANGLES, this.sphere.sphereCount, gl.UNSIGNED_SHORT, 0);
}
this.disableArrays(obj, enabled);
if (typeof obj.polygon_offset !== "undefined") 
gl.disable(gl.POLYGON_OFFSET_FILL);
return;
} else {
if (obj.colorCount === 1) {
gl.disableVertexAttribArray( this.colLoc );
gl.vertexAttrib4fv( this.colLoc, new Float32Array(obj.onecolor));
} else {
gl.enableVertexAttribArray( this.colLoc );
enabled.colLoc = true;
gl.vertexAttribPointer(this.colLoc, 4, gl.FLOAT, false, 4*obj.vOffsets.stride, 4*obj.vOffsets.cofs);
}
}
if (is_lit && obj.vOffsets.nofs > 0) {
gl.enableVertexAttribArray( obj.normLoc );
enabled.normLoc = true;
gl.vertexAttribPointer(obj.normLoc, 3, gl.FLOAT, false, 4*obj.vOffsets.stride, 4*obj.vOffsets.nofs);
}
if (has_texture || type === "text") {
gl.enableVertexAttribArray( obj.texLoc );
enabled.texLoc = true;
gl.vertexAttribPointer(obj.texLoc, 2, gl.FLOAT, false, 4*obj.vOffsets.stride, 4*obj.vOffsets.tofs);
gl.activeTexture(gl.TEXTURE0);
gl.bindTexture(gl.TEXTURE_2D, obj.texture);
gl.uniform1i( obj.sampler, 0);
}
if (fixed_quads) {
gl.enableVertexAttribArray( obj.ofsLoc );
enabled.ofsLoc = true;
gl.vertexAttribPointer(obj.ofsLoc, 2, gl.FLOAT, false, 4*obj.vOffsets.stride, 4*obj.vOffsets.oofs);
}
if (typeof obj.userAttributes !== "undefined") {
for (attr in obj.userAttribSizes) {  // Not all attributes may have been used
gl.enableVertexAttribArray( obj.userAttribLocations[attr] );
gl.vertexAttribPointer( obj.userAttribLocations[attr], obj.userAttribSizes[attr],
gl.FLOAT, false, 4*obj.vOffsets.stride, 4*obj.userAttribOffsets[attr]);
}
}
if (typeof obj.userUniforms !== "undefined") {
for (attr in obj.userUniformLocations) {
var loc = obj.userUniformLocations[attr];
if (loc !== null) {
var uniform = obj.userUniforms[attr];
if (typeof uniform.length === "undefined")
gl.uniform1f(loc, uniform);
else if (typeof uniform[0].length === "undefined") {
uniform = new Float32Array(uniform);
switch(uniform.length) {
case 2: gl.uniform2fv(loc, uniform); break;
case 3: gl.uniform3fv(loc, uniform); break;
case 4: gl.uniform4fv(loc, uniform); break;
default: console.warn("bad uniform length");
}
} else if (uniform.length == 4 && uniform[0].length == 4)
gl.uniformMatrix4fv(loc, false, new Float32Array(uniform.getAsArray()));
else
console.warn("unsupported uniform matrix");
}
}
}
for (pass = 0; pass < obj.passes; pass++) {
pmode = obj.pmode[pass];
if (pmode === "culled")
continue;
mode = fat_lines && (is_lines || pmode == "lines") ? "TRIANGLES" : this.mode4type[type];
if (depth_sort && pmode == "filled") {// Don't try depthsorting on wireframe or points
var faces = this.depthSort(obj),
nfaces = faces.length,
frowsize = Math.floor(obj.f[pass].length/nfaces);
if (type !== "spheres") {
var f = obj.index_uint ? new Uint32Array(obj.f[pass].length) : new Uint16Array(obj.f[pass].length);
for (i=0; i<nfaces; i++) {
for (j=0; j<frowsize; j++) {
f[frowsize*i + j] = obj.f[pass][frowsize*faces[i] + j];
}
}
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, obj.ibuf[pass]);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, f, gl.DYNAMIC_DRAW);
}
}
if (is_twosided)
gl.uniform1i(obj.frontLoc, pass !== 0);
if (type !== "spheres") 
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, obj.ibuf[pass]);
if (type === "sprites" || type === "text" || type === "quads") {
count = count * 6/4;
} else if (type === "surface") {
count = obj.f[pass].length;
}
count = obj.f[pass].length;
if (!is_lines && pmode === "lines" && !fat_lines) {
mode = "LINES";
} else if (pmode === "points") {
mode = "POINTS";
}
if ((is_lines || pmode === "lines") && fat_lines) {
gl.enableVertexAttribArray(obj.pointLoc);
enabled.pointLoc = true;
gl.vertexAttribPointer(obj.pointLoc, 2, gl.FLOAT, false, 4*obj.vOffsets.stride, 4*obj.vOffsets.pointofs);
gl.enableVertexAttribArray(obj.nextLoc );
enabled.nextLoc = true;
gl.vertexAttribPointer(obj.nextLoc, 3, gl.FLOAT, false, 4*obj.vOffsets.stride, 4*obj.vOffsets.nextofs);
gl.uniform1f(obj.aspectLoc, this.vp.width/this.vp.height);
gl.uniform1f(obj.lwdLoc, this.getMaterial(id, "lwd")/this.vp.height);
}
gl.vertexAttribPointer(this.posLoc,  3, gl.FLOAT, false, 4*obj.vOffsets.stride,  4*obj.vOffsets.vofs);
gl.drawElements(gl[mode], count, obj.index_uint ? gl.UNSIGNED_INT : gl.UNSIGNED_SHORT, 0);
this.disableArrays(obj, enabled);
}
if (typeof obj.polygon_offset !== "undefined") 
gl.disable(gl.POLYGON_OFFSET_FILL);
};
/**
* Draw the background for a subscene
* @param { number } id - id of background object
* @param { number } subsceneid - id of subscene
*/
rglwidgetClass.prototype.drawBackground = function(id, subsceneid) {
var gl = this.gl || this.initGL(),
obj = this.getObj(id),
bg, i;
if (!obj.initialized)
this.initObj(id);
if (obj.colors.length) {
bg = obj.colors[0];
gl.clearColor(bg[0], bg[1], bg[2], bg[3]);
gl.depthMask(true);
gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
}
if (typeof obj.quad !== "undefined") {
this.prMatrix.makeIdentity();
this.mvMatrix.makeIdentity();
gl.disable(gl.BLEND);
gl.disable(gl.DEPTH_TEST);
gl.depthMask(false);
for (i=0; i < obj.quad.length; i++)
this.drawObj(obj.quad[i], subsceneid);
}
};
/**
* Draw a subscene
* @param { number } subsceneid - id of subscene
* @param { boolean } opaquePass - is this the opaque drawing pass?
*/
rglwidgetClass.prototype.drawSubscene = function(subsceneid, opaquePass) {
var gl = this.gl || this.initGL(),
sub = this.getObj(subsceneid),
objects = this.scene.objects,
subids = sub.objects,
subscene_has_faces = false,
subscene_needs_sorting = false,
flags, i, obj;
if (sub.par3d.skipRedraw)
return;
for (i=0; i < subids.length; i++) {
obj = objects[subids[i]];
flags = obj.flags;
if (typeof flags !== "undefined") {
subscene_has_faces |= (flags & this.f_is_lit)
& !(flags & this.f_fixed_quads);
obj.is_transparent = (flags & this.f_is_transparent) || obj.someHidden;
subscene_needs_sorting |= (flags & this.f_depth_sort) || obj.is_transparent;
}
}
this.setViewport(subsceneid);
if (typeof sub.backgroundId !== "undefined" && opaquePass)
this.drawBackground(sub.backgroundId, subsceneid);
if (subids.length) {
this.setprMatrix(subsceneid);
this.setmvMatrix(subsceneid);
if (subscene_has_faces) {
this.setnormMatrix(subsceneid);
if ((sub.flags & this.f_sprites_3d) &&
typeof sub.spriteNormmat === "undefined") {
sub.spriteNormmat = new CanvasMatrix4(this.normMatrix);
}
}
if (subscene_needs_sorting)
this.setprmvMatrix();
var clipids = sub.clipplanes;
if (typeof clipids === "undefined") {
console.warn("bad clipids");
}
if (clipids.length > 0) {
this.invMatrix = new CanvasMatrix4(this.mvMatrix);
this.invMatrix.invert();
for (i = 0; i < clipids.length; i++)
this.drawObj(clipids[i], subsceneid);
}
subids = sub.opaque.concat(sub.transparent);
if (opaquePass) {
gl.enable(gl.DEPTH_TEST);
gl.depthMask(true);
gl.disable(gl.BLEND);
for (i = 0; i < subids.length; i++) {
if (!this.getObj(subids[i]).is_transparent) 
this.drawObj(subids[i], subsceneid);
}
} else {
gl.depthMask(false);
gl.blendFuncSeparate(gl.SRC_ALPHA, gl.ONE_MINUS_SRC_ALPHA,
gl.ONE, gl.ONE);
gl.enable(gl.BLEND);
for (i = 0; i < subids.length; i++) {
if (this.getObj(subids[i]).is_transparent)
this.drawObj(subids[i], subsceneid);
}
}
subids = sub.subscenes;
for (i = 0; i < subids.length; i++) {
this.drawSubscene(subids[i], opaquePass);
}
}
};
/**
* Respond to brush change
*/
rglwidgetClass.prototype.selectionChanged = function() {
var i, j, k, id, subid = this.select.subscene, subscene,
objids, obj,
p1 = this.select.region.p1, p2 = this.select.region.p2,
filter, selection = [], handle, keys, xmin, x, xmax, ymin, y, ymax, z, v,
someHidden;
if (!subid)
return;
subscene = this.getObj(subid);
objids = subscene.objects;
filter = this.scene.crosstalk.filter;
this.setmvMatrix(subid);
this.setprMatrix(subid);
this.setprmvMatrix();
xmin = Math.min(p1.x, p2.x);
xmax = Math.max(p1.x, p2.x);
ymin = Math.min(p1.y, p2.y);
ymax = Math.max(p1.y, p2.y);
for (i = 0; i < objids.length; i++) {
id = objids[i];
j = this.scene.crosstalk.id.indexOf(id);
if (j >= 0) {
keys = this.scene.crosstalk.key[j];
obj = this.getObj(id);
someHidden = false;
for (k = 0; k < keys.length; k++) {
if (filter && filter.indexOf(keys[k]) < 0) {
someHidden = true;
continue;
}
v = [].concat(obj.vertices[k]).concat(1.0);
v = this.multVM(v, this.prmvMatrix);
x = v[0]/v[3];
y = v[1]/v[3];
z = v[2]/v[3];
if (xmin <= x && x <= xmax && ymin <= y && y <= ymax && -1.0 <= z && z <= 1.0) {
selection.push(keys[k]);
} else
someHidden = true;
}
obj.someHidden = someHidden && (filter || selection.length);
obj.initialized = false;
/* Who should we notify?  Only shared data in the current subscene, or everyone? */
if (!this.equalArrays(selection, this.scene.crosstalk.selection)) {
handle = this.scene.crosstalk.sel_handle[j];
handle.set(selection, {rglSubsceneId: this.select.subscene});
}
}
}
};
/**
* Respond to selection or filter change from crosstalk
* @param { Object } event - crosstalk event
* @param { boolean } filter - filter or selection?
*/
rglwidgetClass.prototype.selection = function(event, filter) {
var i, j, ids, obj, keys, crosstalk = this.scene.crosstalk,
selection, someHidden;
// Record the message and find out if this event makes some objects have mixed values:
crosstalk = this.scene.crosstalk;
if (filter) {
filter = crosstalk.filter = event.value;
selection = crosstalk.selection;
} else {  
selection = crosstalk.selection = event.value;
filter = crosstalk.filter;
}
ids = crosstalk.id;
for (i = 0; i < ids.length ; i++) {
obj = this.getObj(ids[i]);
obj.initialized = false;
keys = crosstalk.key[i];
someHidden = false;
for (j = 0; j < keys.length && !someHidden; j++) {
if ((filter && filter.indexOf(keys[j]) < 0) ||
(selection.length && selection.indexOf(keys[j]) < 0))
someHidden = true;
}
obj.someHidden = someHidden;
}
this.drawScene();
};
/**
* Clear the selection brush
* @param { number } except - Subscene that should ignore this request
*/
rglwidgetClass.prototype.clearBrush = function(except) {
if (this.select.subscene != except) {
this.select.state = "inactive";
this.delFromSubscene(this.scene.brushId, this.select.subscene);
}
this.drawScene();
};
/**
* Compute mouse coordinates relative to current canvas
* @returns { Object }
* @param { Object } event - event object from mouse click
*/
rglwidgetClass.prototype.relMouseCoords = function(event) {
var totalOffsetX = 0,
totalOffsetY = 0,
currentElement = this.canvas;
do {
totalOffsetX += currentElement.offsetLeft;
totalOffsetY += currentElement.offsetTop;
currentElement = currentElement.offsetParent;
}
while(currentElement);
var canvasX = event.pageX - totalOffsetX,
canvasY = event.pageY - totalOffsetY;
return {x:canvasX, y:canvasY};
};
/**
* Set mouse handlers for the scene
*/
rglwidgetClass.prototype.setMouseHandlers = function() {
var self = this, activeSubscene, handler,
handlers = {}, drag = 0;
handlers.rotBase = 0;
this.screenToVector = function(x, y) {
var viewport = this.getObj(activeSubscene).par3d.viewport,
width = viewport.width*this.canvas.width,
height = viewport.height*this.canvas.height,
radius = Math.max(width, height)/2.0,
cx = width/2.0,
cy = height/2.0,
px = (x-cx)/radius,
py = (y-cy)/radius,
plen = Math.sqrt(px*px+py*py);
if (plen > 1.e-6) {
px = px/plen;
py = py/plen;
}
var angle = (Math.SQRT2 - plen)/Math.SQRT2*Math.PI/2,
z = Math.sin(angle),
zlen = Math.sqrt(1.0 - z*z);
px = px * zlen;
py = py * zlen;
return [px, py, z];
};
handlers.trackballdown = function(x,y) {
var activeSub = this.getObj(activeSubscene),
activeModel = this.getObj(this.useid(activeSub.id, "model")),
i, l = activeModel.par3d.listeners;
handlers.rotBase = this.screenToVector(x, y);
this.saveMat = [];
for (i = 0; i < l.length; i++) {
activeSub = this.getObj(l[i]);
activeSub.saveMat = new CanvasMatrix4(activeSub.par3d.userMatrix);
}
};
handlers.trackballmove = function(x,y) {
var rotCurrent = this.screenToVector(x,y),
rotBase = handlers.rotBase,
dot = rotBase[0]*rotCurrent[0] +
rotBase[1]*rotCurrent[1] +
rotBase[2]*rotCurrent[2],
angle = Math.acos( dot/this.vlen(rotBase)/this.vlen(rotCurrent) )*180.0/Math.PI,
axis = this.xprod(rotBase, rotCurrent),
objects = this.scene.objects,
activeSub = this.getObj(activeSubscene),
activeModel = this.getObj(this.useid(activeSub.id, "model")),
l = activeModel.par3d.listeners,
i;
for (i = 0; i < l.length; i++) {
activeSub = this.getObj(l[i]);
activeSub.par3d.userMatrix.load(objects[l[i]].saveMat);
activeSub.par3d.userMatrix.rotate(angle, axis[0], axis[1], axis[2]);
}
this.drawScene();
};
handlers.trackballend = 0;
this.clamp = function(x, lo, hi) {
return Math.max(lo, Math.min(x, hi));
};
this.screenToPolar = function(x,y) {
var viewport = this.getObj(activeSubscene).par3d.viewport,
width = viewport.width*this.canvas.width,
height = viewport.height*this.canvas.height,
r = Math.min(width, height)/2,
dx = this.clamp(x - width/2, -r, r),
dy = this.clamp(y - height/2, -r, r);
return [Math.asin(dx/r), Math.asin(-dy/r)];
};
handlers.polardown = function(x,y) {
var activeSub = this.getObj(activeSubscene),
activeModel = this.getObj(this.useid(activeSub.id, "model")),
i, l = activeModel.par3d.listeners;
handlers.dragBase = this.screenToPolar(x, y);
this.saveMat = [];
for (i = 0; i < l.length; i++) {
activeSub = this.getObj(l[i]);
activeSub.saveMat = new CanvasMatrix4(activeSub.par3d.userMatrix);
activeSub.camBase = [-Math.atan2(activeSub.saveMat.m13, activeSub.saveMat.m11),
Math.atan2(activeSub.saveMat.m32, activeSub.saveMat.m22)];
}
};
handlers.polarmove = function(x,y) {
var dragCurrent = this.screenToPolar(x,y),
activeSub = this.getObj(activeSubscene),
activeModel = this.getObj(this.useid(activeSub.id, "model")),
objects = this.scene.objects,
l = activeModel.par3d.listeners,
i, changepos = [];
for (i = 0; i < l.length; i++) {
activeSub = this.getObj(l[i]);
for (j=0; j<2; j++)
changepos[j] = -(dragCurrent[j] - handlers.dragBase[j]);
activeSub.par3d.userMatrix.makeIdentity();
activeSub.par3d.userMatrix.rotate(changepos[0]*180/Math.PI, 0,-1,0);
activeSub.par3d.userMatrix.multRight(objects[l[i]].saveMat);
activeSub.par3d.userMatrix.rotate(changepos[1]*180/Math.PI, -1,0,0);
}
this.drawScene();
};
handlers.polarend = 0;
handlers.axisdown = function(x,y) {
handlers.rotBase = this.screenToVector(x, this.canvas.height/2);
var activeSub = this.getObj(activeSubscene),
activeModel = this.getObj(this.useid(activeSub.id, "model")),
i, l = activeModel.par3d.listeners;
for (i = 0; i < l.length; i++) {
activeSub = this.getObj(l[i]);
activeSub.saveMat = new CanvasMatrix4(activeSub.par3d.userMatrix);
}
};
handlers.axismove = function(x,y) {
var rotCurrent = this.screenToVector(x, this.canvas.height/2),
rotBase = handlers.rotBase,
angle = (rotCurrent[0] - rotBase[0])*180/Math.PI,
rotMat = new CanvasMatrix4();
rotMat.rotate(angle, handlers.axis[0], handlers.axis[1], handlers.axis[2]);
var activeSub = this.getObj(activeSubscene),
activeModel = this.getObj(this.useid(activeSub.id, "model")),
i, l = activeModel.par3d.listeners;
for (i = 0; i < l.length; i++) {
activeSub = this.getObj(l[i]);
activeSub.par3d.userMatrix.load(activeSub.saveMat);
activeSub.par3d.userMatrix.multLeft(rotMat);
}
this.drawScene();
};
handlers.axisend = 0;
handlers.y0zoom = 0;
handlers.zoom0 = 0;
handlers.zoomdown = function(x, y) {
var activeSub = this.getObj(activeSubscene),
activeProjection = this.getObj(this.useid(activeSub.id, "projection")),
i, l = activeProjection.par3d.listeners;
handlers.y0zoom = y;
for (i = 0; i < l.length; i++) {
activeSub = this.getObj(l[i]);
activeSub.zoom0 = Math.log(activeSub.par3d.zoom);
}
};
handlers.zoommove = function(x, y) {
var activeSub = this.getObj(activeSubscene),
activeProjection = this.getObj(this.useid(activeSub.id, "projection")),
i, l = activeProjection.par3d.listeners;
for (i = 0; i < l.length; i++) {
activeSub = this.getObj(l[i]);
activeSub.par3d.zoom = Math.exp(activeSub.zoom0 + (y-handlers.y0zoom)/this.canvas.height);
}
this.drawScene();
};
handlers.zoomend = 0;
handlers.y0fov = 0;
handlers.fovdown = function(x, y) {
handlers.y0fov = y;
var activeSub = this.getObj(activeSubscene),
activeProjection = this.getObj(this.useid(activeSub.id, "projection")),
i, l = activeProjection.par3d.listeners;
for (i = 0; i < l.length; i++) {
activeSub = this.getObj(l[i]);
activeSub.fov0 = activeSub.par3d.FOV;
}
};
handlers.fovmove = function(x, y) {
var activeSub = this.getObj(activeSubscene),
activeProjection = this.getObj(this.useid(activeSub.id, "projection")),
i, l = activeProjection.par3d.listeners;
for (i = 0; i < l.length; i++) {
activeSub = this.getObj(l[i]);
activeSub.par3d.FOV = Math.max(1, Math.min(179, activeSub.fov0 +
180*(y-handlers.y0fov)/this.canvas.height));
}
this.drawScene();
};
handlers.fovend = 0;
handlers.selectingdown = function(x, y) {
var viewport = this.getObj(activeSubscene).par3d.viewport,
width = viewport.width*this.canvas.width,
height = viewport.height*this.canvas.height, 
p = {x: 2.0*x/width - 1.0, y: 2.0*y/height - 1.0};
this.select.region = {p1: p, p2: p};
if (this.select.subscene && this.select.subscene != activeSubscene)
this.delFromSubscene(this.scene.brushId, this.select.subscene);
this.select.subscene = activeSubscene;
this.addToSubscene(this.scene.brushId, activeSubscene);
this.select.state = "changing";
if (typeof this.scene.brushId !== "undefined")
this.getObj(this.scene.brushId).initialized = false;
this.drawScene();
};
handlers.selectingmove = function(x, y) {
var viewport = this.getObj(activeSubscene).par3d.viewport,
width = viewport.width*this.canvas.width,
height = viewport.height*this.canvas.height;
if (this.select.state === "inactive") 
return;
this.select.region.p2 = {x: 2.0*x/width - 1.0, y: 2.0*y/height - 1.0};
if (typeof this.scene.brushId !== "undefined")
this.getObj(this.scene.brushId).initialized = false;
this.drawScene();
};
handlers.selectingend = 0;
this.canvas.onmousedown = function ( ev ){
if (!ev.which) // Use w3c defns in preference to MS
switch (ev.button) {
case 0: ev.which = 1; break;
case 1:
case 4: ev.which = 2; break;
case 2: ev.which = 3;
}
drag = ["left", "middle", "right"][ev.which-1];
var coords = self.relMouseCoords(ev);
coords.y = self.canvas.height-coords.y;
activeSubscene = self.whichSubscene(coords);
var sub = self.getObj(activeSubscene), f;
handler = sub.par3d.mouseMode[drag];
switch (handler) {
case "xAxis":
handler = "axis";
handlers.axis = [1.0, 0.0, 0.0];
break;
case "yAxis":
handler = "axis";
handlers.axis = [0.0, 1.0, 0.0];
break;
case "zAxis":
handler = "axis";
handlers.axis = [0.0, 0.0, 1.0];
break;
}
f = handlers[handler + "down"];
if (f) {
coords = self.translateCoords(activeSubscene, coords);
f.call(self, coords.x, coords.y);
ev.preventDefault();
} else
console.warn("Mouse handler '" + handler + "' is not implemented.");
};
this.canvas.onmouseup = function ( ev ){
if ( drag === 0 ) return;
var f = handlers[handler + "end"];
if (f) {
f.call(self);
ev.preventDefault();
}
drag = 0;
};
this.canvas.onmouseout = this.canvas.onmouseup;
this.canvas.onmousemove = function ( ev ) {
if ( drag === 0 ) return;
var f = handlers[handler + "move"];
if (f) {
var coords = self.relMouseCoords(ev);
coords.y = self.canvas.height - coords.y;
coords = self.translateCoords(activeSubscene, coords);
f.call(self, coords.x, coords.y);
}
};
handlers.wheelHandler = function(ev) {
var del = 1.02, i;
if (ev.shiftKey) del = 1.002;
var ds = ((ev.detail || ev.wheelDelta) > 0) ? del : (1 / del);
if (typeof activeSubscene === "undefined")
activeSubscene = self.scene.rootSubscene;
var activeSub = self.getObj(activeSubscene),
activeProjection = self.getObj(self.useid(activeSub.id, "projection")),
l = activeProjection.par3d.listeners;
for (i = 0; i < l.length; i++) {
activeSub = self.getObj(l[i]);
activeSub.par3d.zoom *= ds;
}
self.drawScene();
ev.preventDefault();
};
this.canvas.addEventListener("DOMMouseScroll", handlers.wheelHandler, false);
this.canvas.addEventListener("mousewheel", handlers.wheelHandler, false);
};
/**
* Find a particular subscene by inheritance
* @returns { number } id of subscene to use
* @param { number } subsceneid - child subscene
* @param { string } type - type of inheritance:  "projection" or "model"
*/
rglwidgetClass.prototype.useid = function(subsceneid, type) {
var sub = this.getObj(subsceneid);
if (sub.embeddings[type] === "inherit")
return(this.useid(sub.parent, type));
else
return subsceneid;
};
/**
* Check whether point is in viewport of subscene
* @returns {boolean}
* @param { Object } coords - screen coordinates of point
* @param { number } subsceneid - subscene to check
*/
rglwidgetClass.prototype.inViewport = function(coords, subsceneid) {
var viewport = this.getObj(subsceneid).par3d.viewport,
x0 = coords.x - viewport.x*this.canvas.width,
y0 = coords.y - viewport.y*this.canvas.height;
return 0 <= x0 && x0 <= viewport.width*this.canvas.width &&
0 <= y0 && y0 <= viewport.height*this.canvas.height;
};
/**
* Find which subscene contains a point
* @returns { number } subscene id
* @param { Object } coords - coordinates of point
*/
rglwidgetClass.prototype.whichSubscene = function(coords) {
var self = this,
recurse = function(subsceneid) {
var subscenes = self.getChildSubscenes(subsceneid), i, id;
for (i=0; i < subscenes.length; i++) {
id = recurse(subscenes[i]);
if (typeof(id) !== "undefined")
return(id);
}
if (self.inViewport(coords, subsceneid))
return(subsceneid);
else
return undefined;
},
rootid = this.scene.rootSubscene,
result = recurse(rootid);
if (typeof(result) === "undefined")
result = rootid;
return result;
};
/**
* Translate from window coordinates to viewport coordinates
* @returns { Object } translated coordinates
* @param { number } subsceneid - which subscene to use?
* @param { Object } coords - point to translate
*/
rglwidgetClass.prototype.translateCoords = function(subsceneid, coords) {
var viewport = this.getObj(subsceneid).par3d.viewport;
return {x: coords.x - viewport.x*this.canvas.width,
y: coords.y - viewport.y*this.canvas.height};
};
/**
* Initialize the sphere object
*/
rglwidgetClass.prototype.initSphere = function() {
var verts = this.scene.sphereVerts,
reuse = verts.reuse, result;
if (typeof reuse !== "undefined") {
var prev = document.getElementById(reuse).rglinstance.sphere;
result = {values: prev.values, vOffsets: prev.vOffsets, it: prev.it};
} else
result = {values: new Float32Array(this.flatten(this.cbind(this.transpose(verts.vb),
this.transpose(verts.texcoords)))),
it: new Uint16Array(this.flatten(this.transpose(verts.it))),
vOffsets: {vofs:0, cofs:-1, nofs:-1, radofs:-1, oofs:-1,
tofs:3, nextofs:-1, pointofs:-1, stride:5}};
result.sphereCount = result.it.length;
this.sphere = result;
};
/**
* Set the vertices in the selection box object
*/
rglwidgetClass.prototype.initSelection = function(id) {
if (typeof this.select.region === "undefined")
return;
var obj = this.getObj(id),
width = this.canvas.width,
height = this.canvas.height, 
p1 = this.select.region.p1,
p2 = this.select.region.p2;
obj.vertices = [[p1.x, p1.y, 0.0],
[p2.x, p1.y, 0.0],
[p2.x, p2.y, 0.0],
[p1.x, p2.y, 0.0],
[p1.x, p1.y, 0.0]];
};
/**
* Do the gl part of initializing the sphere
*/
rglwidgetClass.prototype.initSphereGL = function() {
var gl = this.gl || this.initGL(), sphere = this.sphere;
if (gl.isContextLost()) return;
sphere.buf = gl.createBuffer();
gl.bindBuffer(gl.ARRAY_BUFFER, sphere.buf);
gl.bufferData(gl.ARRAY_BUFFER, sphere.values, gl.STATIC_DRAW);
sphere.ibuf = gl.createBuffer();
gl.bindBuffer(gl.ELEMENT_ARRAY_BUFFER, sphere.ibuf);
gl.bufferData(gl.ELEMENT_ARRAY_BUFFER, sphere.it, gl.STATIC_DRAW);
return;
};
/**
* Initialize the DOM object
* @param { Object } el - the DOM object
* @param { Object } x - the scene data sent by JSON from R
*/
rglwidgetClass.prototype.initialize = function(el, x) {
this.textureCanvas = document.createElement("canvas");
this.textureCanvas.style.display = "block";
this.scene = x;
this.normMatrix = new CanvasMatrix4();
this.saveMat = {};
this.distance = null;
this.posLoc = 0;
this.colLoc = 1;
if (el) {
el.rglinstance = this;
this.el = el;
this.webGLoptions = el.rglinstance.scene.webGLoptions;
this.initCanvas();
}
if (typeof Shiny !== "undefined") {
var self = this;
Shiny.addCustomMessageHandler("shinyGetPar3d",
function(message) {
var i, param, 
subscene = self.getObj(message.subscene),
parameters = [].concat(message.parameters),
result = {tag: message.tag, subscene: message.subscene};
if (typeof subscene !== "undefined") {
for (i = 0; i < parameters.length; i++) {
param = parameters[i];
result[param] = subscene.par3d[param];
};
} else {
console.log("subscene "+message.subscene+" undefined.")
}
Shiny.setInputValue("par3d:shinyPar3d", result, {priority: "event"});
});
Shiny.addCustomMessageHandler("shinySetPar3d",
function(message) {
var param = message.parameter, 
subscene = self.getObj(message.subscene);
if (typeof subscene !== "undefined") {
subscene.par3d[param] = message.value;
subscene.initialized = false;
self.drawScene();
} else {
console.log("subscene "+message.subscene+" undefined.")
}
})
}
};
/**
* Restart the WebGL canvas
*/
rglwidgetClass.prototype.restartCanvas = function() {
var newcanvas = document.createElement("canvas"),
self = this;
newcanvas.width = this.el.width;
newcanvas.height = this.el.height;
newcanvas.addEventListener("webglcontextrestored",
this.onContextRestored, false);
newcanvas.addEventListener("webglcontextlost",
this.onContextLost, false);
while (this.el.firstChild) {
this.el.removeChild(this.el.firstChild);
}
this.el.appendChild(newcanvas);
this.canvas = newcanvas;
this.setMouseHandlers();
if (this.gl) 
Object.keys(this.scene.objects).forEach(function(key){
self.getObj(parseInt(key, 10)).texture = undefined; 
});
this.gl = null;
};
/**
* Initialize the WebGL canvas
*/
rglwidgetClass.prototype.initCanvas = function() {
this.restartCanvas();
var objs = this.scene.objects,
self = this;
Object.keys(objs).forEach(function(key){
var id = parseInt(key, 10),
obj = self.getObj(id);
if (typeof obj.reuse !== "undefined")
self.copyObj(id, obj.reuse);
});
Object.keys(objs).forEach(function(key){
self.initSubscene(parseInt(key, 10));
});
this.setMouseHandlers();
this.initSphere();
this.onContextRestored = function(event) {
self.initGL();
self.drawScene();
};
this.onContextLost = function(event) {
if (!self.drawing)
this.gl = null;
event.preventDefault();
};
this.initGL0();
this.lazyLoadScene = function() {
if (typeof self.slide === "undefined")
self.slide = self.getSlide();
if (self.isInBrowserViewport()) {
if (!self.gl || self.gl.isContextLost())
self.initGL();
self.drawScene();
}
};
window.addEventListener("DOMContentLoaded", this.lazyLoadScene, false);
window.addEventListener("load", this.lazyLoadScene, false);
window.addEventListener("resize", this.lazyLoadScene, false);
window.addEventListener("scroll", this.lazyLoadScene, false);
this.slide = this.getSlide();
if (this.slide) {
if (typeof this.slide.rgl === "undefined")
this.slide.rgl = [this];
else
this.slide.rgl.push(this);
if (this.scene.context.rmarkdown) 
if (this.scene.context.rmarkdown === "ioslides_presentation") {
this.slide.setAttribute("slideenter", "this.rgl.forEach(function(scene) { scene.lazyLoadScene.call(window);})");
} else if (this.scene.context.rmarkdown === "slidy_presentation") {
// This method would also work in ioslides, but it gets triggered
// something like 5 times per slide for every slide change, so
// you'd need a quicker function than lazyLoadScene.
var MutationObserver = window.MutationObserver || window.WebKitMutationObserver || window.MozMutationObserver,
observer = new MutationObserver(function(mutations) {
mutations.forEach(function(mutation) {
self.slide.rgl.forEach(function(scene) { scene.lazyLoadScene.call(window); });});});
observer.observe(this.slide, { attributes: true, attributeFilter:["class"] });
}
}
};
/**
* Start the writeWebGL scene. This is only used by writeWebGL; rglwidget has
no debug element and does the drawing in rglwidget.js.
*/
rglwidgetClass.prototype.start = function() {
if (typeof this.prefix !== "undefined") {
this.debugelement = document.getElementById(this.prefix + "debug");
this.debug("");
}
this.drag = 0;
this.drawScene();
};
/**
* Display a debug message
* @param { string } msg - The message to display
* @param { Object } [img] - Image to insert before message
*/
rglwidgetClass.prototype.debug = function(msg, img) {
if (typeof this.debugelement !== "undefined" && this.debugelement !== null) {
this.debugelement.innerHTML = msg;
if (typeof img !== "undefined") {
this.debugelement.insertBefore(img, this.debugelement.firstChild);
}
} else if (msg !== "")
alert(msg);
};
/**
* Get the snapshot image of this scene
* @returns { Object } The img DOM element
*/
rglwidgetClass.prototype.getSnapshot = function() {
var img;
if (typeof this.scene.snapshot !== "undefined") {
img = document.createElement("img");
img.src = this.scene.snapshot;
img.alt = "Snapshot";
}
return img;
};
/**
* Initial test for WebGL
*/
rglwidgetClass.prototype.initGL0 = function() {
if (!window.WebGLRenderingContext){
alert("Your browser does not support WebGL. See http://get.webgl.org");
return;
}
};
/**
* If we are in an ioslides or slidy presentation, get the
* DOM element of the current slide
* @returns { Object }
*/
rglwidgetClass.prototype.getSlide = function() {
var result = this.el, done = false;
while (result && !done && this.scene.context.rmarkdown) {
switch(this.scene.context.rmarkdown) {
case "ioslides_presentation":
if (result.tagName === "SLIDE") return result;
break;
case "slidy_presentation":
if (result.tagName === "DIV" && result.classList.contains("slide"))
return result;
break;
default: return null;
}
result = result.parentElement;
}
return null;
};
/**
* Is this scene visible in the browser?
* @returns { boolean }
*/
rglwidgetClass.prototype.isInBrowserViewport = function() {
var rect = this.canvas.getBoundingClientRect(),
windHeight = (window.innerHeight || document.documentElement.clientHeight),
windWidth = (window.innerWidth || document.documentElement.clientWidth);
if (this.scene.context && this.scene.context.rmarkdown !== null) {
if (this.slide)
return (this.scene.context.rmarkdown === "ioslides_presentation" &&
this.slide.classList.contains("current")) ||
(this.scene.context.rmarkdown === "slidy_presentation" &&
!this.slide.classList.contains("hidden"));
}
return (
rect.top >= -windHeight &&
rect.left >= -windWidth &&
rect.bottom <= 2*windHeight &&
rect.right <= 2*windWidth);
};
/**
* Initialize WebGL
* @returns { Object } the WebGL context
*/
rglwidgetClass.prototype.initGL = function() {
var self = this;
if (this.gl) {
if (!this.drawing && this.gl.isContextLost())
this.restartCanvas();
else
return this.gl;
}
// if (!this.isInBrowserViewport()) return; Return what??? At this point we know this.gl is null.
this.canvas.addEventListener("webglcontextrestored",
this.onContextRestored, false);
this.canvas.addEventListener("webglcontextlost",
this.onContextLost, false);
this.gl = this.canvas.getContext("webgl", this.webGLoptions) ||
this.canvas.getContext("experimental-webgl", this.webGLoptions);
this.index_uint = this.gl.getExtension("OES_element_index_uint");
var save = this.startDrawing();
this.initSphereGL();
Object.keys(this.scene.objects).forEach(function(key){
self.initObj(parseInt(key, 10));
});
this.stopDrawing(save);
return this.gl;
};
/**
* Resize the display to match element
* @param { Object } el - DOM element to match
*/
rglwidgetClass.prototype.resize = function(el) {
this.canvas.width = el.width;
this.canvas.height = el.height;
};
/**
* Draw the whole scene
*/
rglwidgetClass.prototype.drawScene = function() {
var gl = this.gl || this.initGL(),
wasDrawing = this.startDrawing();
if (!wasDrawing) {
if (this.select.state !== "inactive")
this.selectionChanged();
gl.enable(gl.DEPTH_TEST);
gl.depthFunc(gl.LEQUAL);
gl.clearDepth(1.0);
gl.clearColor(1,1,1,1);
gl.depthMask(true); // Must be true before clearing depth buffer
gl.clear(gl.COLOR_BUFFER_BIT | gl.DEPTH_BUFFER_BIT);
this.drawSubscene(this.scene.rootSubscene, true);
this.drawSubscene(this.scene.rootSubscene, false);
}
this.stopDrawing(wasDrawing);
};
/**
* Change the displayed subset
* @param { Object } el - Element of the control; not used.
* @param { Object } control - The subset control data.
*/
rglwidgetClass.prototype.subsetSetter = function(el, control) {
if (typeof control.subscenes === "undefined" ||
control.subscenes === null)
control.subscenes = this.scene.rootSubscene;
var value = Math.round(control.value),
subscenes = [].concat(control.subscenes),
fullset = [].concat(control.fullset),
i, j, entries, subsceneid,
adds = [], deletes = [],
ismissing = function(x) {
return fullset.indexOf(x) < 0;
},
tointeger = function(x) {
return parseInt(x, 10);
};
if (isNaN(value))
value = control.value = 0;
if (control.accumulate)
for (i=0; i <= value; i++)
adds = adds.concat(control.subsets[i]);
else
adds = adds.concat(control.subsets[value]);
deletes = fullset.filter(function(x) { return adds.indexOf(x) < 0; });
for (i = 0; i < subscenes.length; i++) {
subsceneid = subscenes[i];
if (typeof this.getObj(subsceneid) === "undefined")
this.alertOnce("typeof object is undefined");
for (j = 0; j < adds.length; j++)
this.addToSubscene(adds[j], subsceneid);
for (j = 0; j < deletes.length; j++)
this.delFromSubscene(deletes[j], subsceneid);
}
};
/**
* Change the requested property
* @param { Object } el - Element of the control; not used.
* @param { Object } control - The property setter control data.
*/
rglwidgetClass.prototype.propertySetter = function(el, control)  {
var value = control.value,
values = [].concat(control.values),
svals = [].concat(control.param),
direct = values[0] === null,
entries = [].concat(control.entries),
ncol = entries.length,
nrow = values.length/ncol,
properties = this.repeatToLen(control.properties, ncol),
objids = this.repeatToLen(control.objids, ncol),
property, objid = objids[0],
obj = this.getObj(objid),
propvals, i, v1, v2, p, entry, gl, needsBinding,
newprop, newid,
getPropvals = function() {
if (property === "userMatrix")
return obj.par3d.userMatrix.getAsArray();
else if (property === "scale" || property === "FOV" || property === "zoom")
return [].concat(obj.par3d[property]);
else
return [].concat(obj[property]);
};
putPropvals = function(newvals) {
if (newvals.length == 1)
newvals = newvals[0];
if (property === "userMatrix")
obj.par3d.userMatrix.load(newvals);
else if (property === "scale" || property === "FOV" || property === "zoom")
obj.par3d[property] = newvals;
else
obj[property] = newvals;
};
if (direct && typeof value === "undefined")
return;
if (control.interp) {
values = values.slice(0, ncol).concat(values).
concat(values.slice(ncol*(nrow-1), ncol*nrow));
svals = [-Infinity].concat(svals).concat(Infinity);
for (i = 1; i < svals.length; i++) {
if (value <= svals[i]) {
if (svals[i] === Infinity)
p = 1;
else
p = (svals[i] - value)/(svals[i] - svals[i-1]);
break;
}
}
} else if (!direct) {
value = Math.round(value);
}
for (j=0; j<entries.length; j++) {
entry = entries[j];
newprop = properties[j];
newid = objids[j];
if (newprop !== property || newid != objid) {
if (typeof property !== "undefined")
putPropvals(propvals);
property = newprop;
objid = newid;
obj = this.getObj(objid);
propvals = getPropvals();
}
if (control.interp) {
v1 = values[ncol*(i-1) + j];
v2 = values[ncol*i + j];
this.setElement(propvals, entry, p*v1 + (1-p)*v2);
} else if (!direct) {
this.setElement(propvals, entry, values[ncol*value + j]);
} else {
this.setElement(propvals, entry, value[j]);
}
}
putPropvals(propvals);
needsBinding = [];
for (j=0; j < entries.length; j++) {
if (properties[j] === "values" &&
needsBinding.indexOf(objids[j]) === -1) {
needsBinding.push(objids[j]);
}
}
for (j=0; j < needsBinding.length; j++) {
gl = this.gl || this.initGL();
obj = this.getObj(needsBinding[j]);
gl.bindBuffer(gl.ARRAY_BUFFER, obj.buf);
gl.bufferData(gl.ARRAY_BUFFER, obj.values, gl.STATIC_DRAW);
}
};
/**
* Change the requested vertices
* @param { Object } el - Element of the control; not used.
* @param { Object } control - The vertext setter control data.
*/
rglwidgetClass.prototype.vertexSetter = function(el, control)  {
var svals = [].concat(control.param),
j, k, p, a, propvals, stride, ofs, obj, entry,
attrib,
ofss    = {x:"vofs", y:"vofs", z:"vofs",
red:"cofs", green:"cofs", blue:"cofs",
alpha:"cofs", radii:"radofs",
nx:"nofs", ny:"nofs", nz:"nofs",
ox:"oofs", oy:"oofs", oz:"oofs",
ts:"tofs", tt:"tofs"},
pos     = {x:0, y:1, z:2,
red:0, green:1, blue:2,
alpha:3,radii:0,
nx:0, ny:1, nz:2,
ox:0, oy:1, oz:2,
ts:0, tt:1},
values = control.values,
direct = values === null,
ncol,
interp = control.interp,
vertices = [].concat(control.vertices),
attributes = [].concat(control.attributes),
value = control.value, newval, aliases, alias;
ncol = Math.max(vertices.length, attributes.length);
if (!ncol)
return;
vertices = this.repeatToLen(vertices, ncol);
attributes = this.repeatToLen(attributes, ncol);
if (direct)
interp = false;
/* JSON doesn't pass Infinity */
svals[0] = -Infinity;
svals[svals.length - 1] = Infinity;
for (j = 1; j < svals.length; j++) {
if (value <= svals[j]) {
if (interp) {
if (svals[j] === Infinity)
p = 1;
else
p = (svals[j] - value)/(svals[j] - svals[j-1]);
} else {
if (svals[j] - value > value - svals[j-1])
j = j - 1;
}
break;
}
}
obj = this.getObj(control.objid);
// First, make sure color attributes vary in original
if (typeof obj.vOffsets !== "undefined") {
varies = true;
for (k = 0; k < ncol; k++) {
attrib = attributes[k];
if (typeof attrib !== "undefined") {
ofs = obj.vOffsets[ofss[attrib]];
if (ofs < 0) {
switch(attrib) {
case "alpha":
case "red":
case "green":
case "blue":
obj.colors = [obj.colors[0], obj.colors[0]];
break;
}
varies = false;
}
}
}
if (!varies)
this.initObj(control.objid);
}
propvals = obj.values;
aliases = obj.alias;
if (typeof aliases === "undefined")
aliases = [];
for (k=0; k<ncol; k++) {
if (direct) {
newval = value;
} else if (interp) {
newval = p*values[j-1][k] + (1-p)*values[j][k];
} else {
newval = values[j][k];
}       
attrib = attributes[k];
vertex = vertices[k];
alias = aliases[vertex];
if (obj.type === "planes" || obj.type === "clipplanes") {
ofs = ["nx", "ny", "nz", "offset"].indexOf(attrib);
if (ofs >= 0) {
if (ofs < 3) {
if (obj.normals[vertex][ofs] != newval) {  // Assume no aliases here...
obj.normals[vertex][ofs] = newval;
obj.initialized = false;
}
} else {
if (obj.offsets[vertex][0] != newval) {
obj.offsets[vertex][0] = newval;
obj.initialized = false;
}
}
continue;
}
}
// Not a plane setting...
ofs = obj.vOffsets[ofss[attrib]];
if (ofs < 0)
this.alertOnce("Attribute '"+attrib+"' not found in object "+control.objid);
else {
stride = obj.vOffsets.stride;
ofs = ofs + pos[attrib];
entry = vertex*stride + ofs;
propvals[entry] = newval;
if (typeof alias !== "undefined")
for (a = 0; a < alias.length; a++)
propvals[alias[a]*stride + ofs] = newval;
}
}
if (typeof obj.buf !== "undefined") {
var gl = this.gl || this.initGL();
gl.bindBuffer(gl.ARRAY_BUFFER, obj.buf);
gl.bufferData(gl.ARRAY_BUFFER, propvals, gl.STATIC_DRAW);
}
};
/**
* Change the requested vertex properties by age
* @param { Object } el - Element of the control; not used.
* @param { Object } control - The age setter control data.
*/
rglwidgetClass.prototype.ageSetter = function(el, control) {
var objids = [].concat(control.objids),
nobjs = objids.length,
time = control.value,
births = [].concat(control.births),
ages = [].concat(control.ages),
steps = births.length,
j = Array(steps),
p = Array(steps),
i, k, age, j0, propvals, stride, ofs, objid, obj,
attrib, dim, varies, alias, aliases, a, d,
attribs = ["colors", "alpha", "radii", "vertices",
"normals", "origins", "texcoords",
"x", "y", "z",
"red", "green", "blue"],
ofss    = ["cofs", "cofs", "radofs", "vofs",
"nofs", "oofs", "tofs",
"vofs", "vofs", "vofs",
"cofs", "cofs", "cofs"],
dims    = [3,1,1,3,
3,2,2,
1,1,1,
1,1,1],
pos     = [0,3,0,0,
0,0,0,
0,1,2,
0,1,2];
/* Infinity doesn't make it through JSON */
ages[0] = -Infinity;
ages[ages.length-1] = Infinity;
for (i = 0; i < steps; i++) {
if (births[i] !== null) {  // NA in R becomes null
age = time - births[i];
for (j0 = 1; age > ages[j0]; j0++);
if (ages[j0] == Infinity)
p[i] = 1;
else if (ages[j0] > ages[j0-1])
p[i] = (ages[j0] - age)/(ages[j0] - ages[j0-1]);
else
p[i] = 0;
j[i] = j0;
}
}
// First, make sure color attributes vary in original
for (l = 0; l < nobjs; l++) {
objid = objids[l];
obj = this.getObj(objid);
varies = true;
if (typeof obj.vOffsets === "undefined")
continue;
for (k = 0; k < attribs.length; k++) {
attrib = control[attribs[k]];
if (typeof attrib !== "undefined") {
ofs = obj.vOffsets[ofss[k]];
if (ofs < 0) {
switch(attribs[k]) {
case "colors":
case "alpha":
case "red":
case "green":
case "blue":
obj.colors = [obj.colors[0], obj.colors[0]];
break;
}
varies = false;
}
}
}
if (!varies)
this.initObj(objid);
}
for (l = 0; l < nobjs; l++) {
objid = objids[l];
obj = this.getObj(objid);
if (typeof obj.vOffsets === "undefined")
continue;
aliases = obj.alias;
if (typeof aliases === "undefined")
aliases = [];
propvals = obj.values;
stride = obj.vOffsets.stride;
for (k = 0; k < attribs.length; k++) {
attrib = control[attribs[k]];
if (typeof attrib !== "undefined") {
ofs = obj.vOffsets[ofss[k]];
if (ofs >= 0) {
dim = dims[k];
ofs = ofs + pos[k];
for (i = 0; i < steps; i++) {
alias = aliases[i];
if (births[i] !== null) {
for (d=0; d < dim; d++) {
propvals[i*stride + ofs + d] = p[i]*attrib[dim*(j[i]-1) + d] + (1-p[i])*attrib[dim*j[i] + d];
if (typeof alias !== "undefined")
for (a=0; a < alias.length; a++)
propvals[alias[a]*stride + ofs + d] = propvals[i*stride + ofs + d];
}
}
}
} else
this.alertOnce("\'"+attribs[k]+"\' property not found in object "+objid);
}
}
obj.values = propvals;
if (typeof obj.buf !== "undefined") {
gl = this.gl || this.initGL();
gl.bindBuffer(gl.ARRAY_BUFFER, obj.buf);
gl.bufferData(gl.ARRAY_BUFFER, obj.values, gl.STATIC_DRAW);
}
}
};
/**
* Bridge to old style control
* @param { Object } el - Element of the control; not used.
* @param { Object } control - The bridge control data.
*/
rglwidgetClass.prototype.oldBridge = function(el, control) {
var attrname, global = window[control.prefix + "rgl"];
if (global)
for (attrname in global)
this[attrname] = global[attrname];
window[control.prefix + "rgl"] = this;
};
/**
* Set up a player control
* @param { Object } el - The player control element
* @param { Object } control - The player data.
*/
rglwidgetClass.prototype.Player = function(el, control) {
var
self = this,
components = [].concat(control.components),
buttonLabels = [].concat(control.buttonLabels),
Tick = function() { /* "this" will be a timer */
var i,
nominal = this.value,
slider = this.Slider,
labels = this.outputLabels,
output = this.Output,
step;
if (typeof slider !== "undefined" && nominal != slider.value)
slider.value = nominal;
if (typeof output !== "undefined") {
step = Math.round((nominal - output.sliderMin)/output.sliderStep);
if (labels !== null) {
output.innerHTML = labels[step];
} else {
step = step*output.sliderStep + output.sliderMin;
output.innerHTML = step.toPrecision(output.outputPrecision);
}
}
for (i=0; i < this.actions.length; i++) {
this.actions[i].value = nominal;
}
self.applyControls(el, this.actions, false);
self.drawScene();
},
OnSliderInput = function() { /* "this" will be the slider */
this.rgltimer.value = Number(this.value);
this.rgltimer.Tick();
},
addSlider = function(min, max, step, value) {
var slider = document.createElement("input");
slider.type = "range";
slider.min = min;
slider.max = max;
slider.step = step;
slider.value = value;
slider.oninput = OnSliderInput;
slider.sliderActions = control.actions;
slider.sliderScene = this;
slider.className = "rgl-slider";
slider.id = el.id + "-slider";
el.rgltimer.Slider = slider;
slider.rgltimer = el.rgltimer;
el.appendChild(slider);
},
addLabel = function(labels, min, step, precision) {
var output = document.createElement("output");
output.sliderMin = min;
output.sliderStep = step;
output.outputPrecision = precision;
output.className = "rgl-label";
output.id = el.id + "-label";
el.rgltimer.Output = output;
el.rgltimer.outputLabels = labels;
el.appendChild(output);
},
addButton = function(which, label, active) {
var button = document.createElement("input"),
onclicks = {Reverse: function() { this.rgltimer.reverse();},
Play: function() { this.rgltimer.play();
this.value = this.rgltimer.enabled ? this.inactiveValue : this.activeValue; },
Slower: function() { this.rgltimer.slower(); },
Faster: function() { this.rgltimer.faster(); },
Reset: function() { this.rgltimer.reset(); },
Step:  function() { this.rgltimer.step(); }
};
button.rgltimer = el.rgltimer;
button.type = "button";
button.value = label;
button.activeValue = label;
button.inactiveValue = active;
if (which === "Play")
button.rgltimer.PlayButton = button;
button.onclick = onclicks[which];
button.className = "rgl-button";
button.id = el.id + "-" + which;
el.appendChild(button);
};
if (typeof control.reinit !== "undefined" && control.reinit !== null) {
control.actions.reinit = control.reinit;
}
el.rgltimer = new rgltimerClass(Tick, control.start, control.interval, control.stop,
control.step, control.value, control.rate, control.loop, control.actions);
for (var i=0; i < components.length; i++) {
switch(components[i]) {
case "Slider": addSlider(control.start, control.stop,
control.step, control.value);
break;
case "Label": addLabel(control.labels, control.start,
control.step, control.precision);
break;
default:
addButton(components[i], buttonLabels[i], control.pause);
}
}
el.rgltimer.Tick();
};
/**
* Apply all registered controls
* @param { Object } el - DOM element of the control
* @param { Object } x - List of actions to apply
* @param { boolean } [draw=true] - Whether to redraw after applying
*/
rglwidgetClass.prototype.applyControls = function(el, x, draw) {
var self = this, reinit = x.reinit, i, control, type;
for (i = 0; i < x.length; i++) {
control = x[i];
type = control.type;
self[type](el, control);
}
if (typeof reinit !== "undefined" && reinit !== null) {
reinit = [].concat(reinit);
for (i = 0; i < reinit.length; i++)
self.getObj(reinit[i]).initialized = false;
}
if (typeof draw === "undefined" || draw)
self.drawScene();
};
/**
* Handler for scene change
* @param { Object } message - What sort of scene change to do?
*/
rglwidgetClass.prototype.sceneChangeHandler = function(message) {
var self = document.getElementById(message.elementId).rglinstance,
objs = message.objects, mat = message.material,
root = message.rootSubscene,
initSubs = message.initSubscenes,
redraw = message.redrawScene,
skipRedraw = message.skipRedraw,
deletes, subs, allsubs = [], i,j;
if (typeof message.delete !== "undefined") {
deletes = [].concat(message.delete);
if (typeof message.delfromSubscenes !== "undefined")
subs = [].concat(message.delfromSubscenes);
else
subs = [];
for (i = 0; i < deletes.length; i++) {
for (j = 0; j < subs.length; j++) {
self.delFromSubscene(deletes[i], subs[j]);
}
delete self.scene.objects[deletes[i]];
}
}
if (typeof objs !== "undefined") {
Object.keys(objs).forEach(function(key){
key = parseInt(key, 10);
self.scene.objects[key] = objs[key];
self.initObj(key);
var obj = self.getObj(key),
subs = [].concat(obj.inSubscenes), k;
allsubs = allsubs.concat(subs);
for (k = 0; k < subs.length; k++)
self.addToSubscene(key, subs[k]);
});
}
if (typeof mat !== "undefined") {
self.scene.material = mat;
}
if (typeof root !== "undefined") {
self.scene.rootSubscene = root;
}
if (typeof initSubs !== "undefined")
allsubs = allsubs.concat(initSubs);
allsubs = self.unique(allsubs);
for (i = 0; i < allsubs.length; i++) {
self.initSubscene(allsubs[i]);
}
if (typeof skipRedraw !== "undefined") {
root = self.getObj(self.scene.rootSubscene);
root.par3d.skipRedraw = skipRedraw;
}
if (redraw)
self.drawScene();
};
/**
* Set mouse mode for a subscene
* @param { string } mode - name of mode
* @param { number } button - button number (1 to 3)
* @param { number } subscene - subscene id number
* @param { number } stayActive - if truthy, don't clear brush
*/
rglwidgetClass.prototype.setMouseMode = function(mode, button, subscene, stayActive) {
var sub = this.getObj(subscene),
which = ["left", "right", "middle"][button - 1];
if (!stayActive && sub.par3d.mouseMode[which] === "selecting")
this.clearBrush(null);
sub.par3d.mouseMode[which] = mode;
};
/**
* The class of an rgl timer object
* @class
*/
/**
* Construct an rgltimerClass object
* @constructor
* @param { function } Tick - action when timer fires
* @param { number } startTime - nominal start time in seconds
* @param { number } interval - seconds between updates
* @param { number } stopTime - nominal stop time in seconds
* @param { number } stepSize - nominal step size
* @param { number } value - current nominal time
* @param { number } rate - nominal units per second
* @param { string } loop - "none", "cycle" or "oscillate"
* @param { Object } actions - list of actions
*/
rgltimerClass = function(Tick, startTime, interval, stopTime, stepSize, value, rate, loop, actions) {
this.enabled = false;
this.timerId = 0;
/** nominal start time in seconds */
this.startTime = startTime;   
/** current nominal time */      
this.value = value;
/** seconds between updates */                 
this.interval = interval;
/** nominal stop time */           
this.stopTime = stopTime;
/** nominal step size */           
this.stepSize = stepSize;
/** nominal units per second */           
this.rate = rate;
/** "none", "cycle", or "oscillate" */                   
this.loop = loop;
/** real world start time */                   
this.realStart = undefined;
/** multiplier for fast-forward or reverse */         
this.multiplier = 1;                
this.actions = actions;
this.Tick = Tick;
};
/**
* Start playing timer object
*/
rgltimerClass.prototype.play = function() {
if (this.enabled) {
this.enabled = false;
window.clearInterval(this.timerId);
this.timerId = 0;
return;
}
var tick = function(self) {
var now = new Date();
self.value = self.multiplier*self.rate*(now - self.realStart)/1000 + self.startTime;
self.forceToRange();
if (typeof self.Tick !== "undefined") {
self.Tick(self.value);
}
};
this.realStart = new Date() - 1000*(this.value - this.startTime)/this.rate/this.multiplier;
this.timerId = window.setInterval(tick, 1000*this.interval, this);
this.enabled = true;
};
/**
* Force value into legal range
*/
rgltimerClass.prototype.forceToRange = function() {
if (this.value > this.stopTime + this.stepSize/2 || this.value < this.startTime - this.stepSize/2) {
if (!this.loop) {
this.reset();
} else {
var cycle = this.stopTime - this.startTime + this.stepSize,
newval = (this.value - this.startTime) % cycle + this.startTime;
if (newval < this.startTime) {
newval += cycle;
}
this.realStart += (this.value - newval)*1000/this.multiplier/this.rate;
this.value = newval;
}
}
};
/**
* Reset to start values
*/
rgltimerClass.prototype.reset = function() {
this.value = this.startTime;
this.newmultiplier(1);
if (typeof this.Tick !== "undefined") {
this.Tick(this.value);
}
if (this.enabled)
this.play();  /* really pause... */
if (typeof this.PlayButton !== "undefined")
this.PlayButton.value = "Play";
};
/**
* Increase the multiplier to play faster
*/
rgltimerClass.prototype.faster = function() {
this.newmultiplier(Math.SQRT2*this.multiplier);
};
/**
* Decrease the multiplier to play slower
*/
rgltimerClass.prototype.slower = function() {
this.newmultiplier(this.multiplier/Math.SQRT2);
};
/**
* Change sign of multiplier to reverse direction
*/
rgltimerClass.prototype.reverse = function() {
this.newmultiplier(-this.multiplier);
};
/**
* Set multiplier for play speed
* @param { number } newmult - new value
*/
rgltimerClass.prototype.newmultiplier = function(newmult) {
if (newmult != this.multiplier) {
this.realStart += 1000*(this.value - this.startTime)/this.rate*(1/this.multiplier - 1/newmult);
this.multiplier = newmult;
}
};
/**
* Take one step
*/
rgltimerClass.prototype.step = function() {
this.value += this.rate*this.multiplier;
this.forceToRange();
if (typeof this.Tick !== "undefined")
this.Tick(this.value);
};</script>
<div id="webshot__is_phantomjs_installed__div" class="rglWebGL">

</div>
<script type="text/javascript">
var webshot__is_phantomjs_installed__div = document.getElementById("webshot__is_phantomjs_installed__div"),
webshot__is_phantomjs_installed__rgl = new rglwidgetClass();
webshot__is_phantomjs_installed__div.width = 289;
webshot__is_phantomjs_installed__div.height = 289;
webshot__is_phantomjs_installed__rgl.initialize(webshot__is_phantomjs_installed__div,
{"material":{"color":"#DF536B","alpha":1,"lit":true,"ambient":"#000000","specular":"#FFFFFF","emission":"#000000","shininess":50,"smooth":true,"front":"filled","back":"filled","size":3,"lwd":1,"fog":true,"point_antialias":false,"line_antialias":false,"texture":null,"textype":"rgb","texmipmap":false,"texminfilter":"linear","texmagfilter":"linear","texenvmap":false,"depth_mask":true,"depth_test":"less","isTransparent":false,"polygon_offset":[0,0]},"rootSubscene":6,"objects":{"13":{"id":13,"type":"triangles","material":{},"vertices":[[1.537181,-5.461595,7.051492],[2.982136,-6.446404,6.18961],[1.285912,-6.463083,8.747848],[1.537181,-5.461595,7.051492],[2.982136,-6.446404,6.18961],[0.05050284,-3.552675,2.004682],[1.537181,-5.461595,7.051492],[1.285912,-6.463083,8.747848],[0.05050284,-3.552675,2.004682],[-0.5931032,-2.653636,-6.401013],[2.50443,-4.157528,-1.968361],[0.1211158,-3.925476,-3.498543],[-0.5931032,-2.653636,-6.401013],[2.50443,-4.157528,-1.968361],[-0.5649692,-2.215669,-7.663503],[-0.5931032,-2.653636,-6.401013],[-0.5864934,-1.811569,-2.33015],[-0.1435631,-3.200657,-2.888103],[-0.5931032,-2.653636,-6.401013],[-0.5864934,-1.811569,-2.33015],[-1.560871,0.5478706,-3.144658],[-0.5931032,-2.653636,-6.401013],[-0.1435631,-3.200657,-2.888103],[-0.1012848,-3.182452,-4.395331],[-0.5931032,-2.653636,-6.401013],[-3.210924,4.629865,-6.612557],[-1.560871,0.5478706,-3.144658],[-0.5931032,-2.653636,-6.401013],[-3.210924,4.629865,-6.612557],[-0.5649692,-2.215669,-7.663503],[-0.5931032,-2.653636,-6.401013],[0.1211158,-3.925476,-3.498543],[-0.1012848,-3.182452,-4.395331],[-5.3525,11.57575,-22.91605],[-4.525235,7.813531,-13.61007],[-4.881009,10.5708,-9.257639],[3.167072,-1.344741,-3.810746],[-1.296392,0.46233,-2.786833],[2.32015,0.01343586,5.900407],[3.167072,-1.344741,-3.810746],[-1.296392,0.46233,-2.786833],[-3.210924,4.629865,-6.612557],[3.167072,-1.344741,-3.810746],[2.50443,-4.157528,-1.968361],[7.582676,-2.460481,1.505083],[3.167072,-1.344741,-3.810746],[2.50443,-4.157528,-1.968361],[-0.5649692,-2.215669,-7.663503],[3.167072,-1.344741,-3.810746],[2.32015,0.01343586,5.900407],[7.582676,-2.460481,1.505083],[3.167072,-1.344741,-3.810746],[-3.210924,4.629865,-6.612557],[-0.5649692,-2.215669,-7.663503],[-0.03134485,-3.324157,3.230353],[-2.053592,-0.3725095,5.143529],[1.285912,-6.463083,8.747848],[-0.03134485,-3.324157,3.230353],[-2.053592,-0.3725095,5.143529],[0.05050284,-3.552675,2.004682],[-0.03134485,-3.324157,3.230353],[1.285912,-6.463083,8.747848],[0.05050284,-3.552675,2.004682],[-1.296392,0.46233,-2.786833],[2.32015,0.01343586,5.900407],[-4.710948,5.357959,-0.6206625],[-1.296392,0.46233,-2.786833],[-3.210924,4.629865,-6.612557],[-4.710948,5.357959,-0.6206625],[2.50443,-4.157528,-1.968361],[0.1211158,-3.925476,-3.498543],[0.1160741,-3.478288,-0.6629848],[2.50443,-4.157528,-1.968361],[2.982136,-6.446404,6.18961],[7.582676,-2.460481,1.505083],[2.50443,-4.157528,-1.968361],[2.982136,-6.446404,6.18961],[0.1160741,-3.478288,-0.6629848],[8.60483,-7.044188,8.355405],[2.982136,-6.446404,6.18961],[7.582676,-2.460481,1.505083],[-2.053592,-0.3725095,5.143529],[-0.5864934,-1.811569,-2.33015],[-1.560871,0.5478706,-3.144658],[-2.053592,-0.3725095,5.143529],[-0.5864934,-1.811569,-2.33015],[0.05050284,-3.552675,2.004682],[-2.053592,-0.3725095,5.143529],[0.7465857,-1.859596,6.500604],[1.285912,-6.463083,8.747848],[-2.053592,-0.3725095,5.143529],[0.7465857,-1.859596,6.500604],[-4.030569,8.407826,9.524559],[-2.053592,-0.3725095,5.143529],[-4.710948,5.357959,-0.6206625],[-1.560871,0.5478706,-3.144658],[-2.053592,-0.3725095,5.143529],[-4.710948,5.357959,-0.6206625],[-4.030569,8.407826,9.524559],[-0.5864934,-1.811569,-2.33015],[-0.1435631,-3.200657,-2.888103],[0.1160741,-3.478288,-0.6629848],[-0.5864934,-1.811569,-2.33015],[0.05050284,-3.552675,2.004682],[0.1160741,-3.478288,-0.6629848],[-0.1435631,-3.200657,-2.888103],[0.1211158,-3.925476,-3.498543],[-0.1012848,-3.182452,-4.395331],[-0.1435631,-3.200657,-2.888103],[0.1211158,-3.925476,-3.498543],[0.1160741,-3.478288,-0.6629848],[7.786225,6.783995,11.36444],[2.32015,0.01343586,5.900407],[-4.710948,5.357959,-0.6206625],[7.786225,6.783995,11.36444],[2.32015,0.01343586,5.900407],[7.582676,-2.460481,1.505083],[7.786225,6.783995,11.36444],[0.7465857,-1.859596,6.500604],[1.285912,-6.463083,8.747848],[7.786225,6.783995,11.36444],[0.7465857,-1.859596,6.500604],[-4.030569,8.407826,9.524559],[7.786225,6.783995,11.36444],[-3.574318,10.83505,10.33871],[-4.030569,8.407826,9.524559],[7.786225,6.783995,11.36444],[-4.710948,5.357959,-0.6206625],[-4.030569,8.407826,9.524559],[-3.210924,4.629865,-6.612557],[-4.525235,7.813531,-13.61007],[-4.881009,10.5708,-9.257639],[-3.210924,4.629865,-6.612557],[-4.525235,7.813531,-13.61007],[-0.5649692,-2.215669,-7.663503],[-3.210924,4.629865,-6.612557],[-4.710948,5.357959,-0.6206625],[-4.881009,10.5708,-9.257639],[-3.210924,4.629865,-6.612557],[-4.710948,5.357959,-0.6206625],[-1.560871,0.5478706,-3.144658],[-4.713354,9.561626,9.444035],[-3.574318,10.83505,10.33871],[-4.710948,5.357959,-0.6206625],[-4.713354,9.561626,9.444035],[-4.710948,5.357959,-0.6206625],[-4.030569,8.407826,9.524559],[-3.574318,10.83505,10.33871],[-4.710948,5.357959,-0.6206625],[-4.030569,8.407826,9.524559],[2.982136,-6.446404,6.18961],[0.05050284,-3.552675,2.004682],[0.1160741,-3.478288,-0.6629848],[-4.713354,9.561626,9.444035],[-3.574318,10.83505,10.33871],[-4.030569,8.407826,9.524559],[8.60483,-7.044188,8.355405],[7.786225,6.783995,11.36444],[7.582676,-2.460481,1.505083],[8.60483,-7.044188,8.355405],[7.786225,6.783995,11.36444],[1.285912,-6.463083,8.747848],[8.60483,-7.044188,8.355405],[2.982136,-6.446404,6.18961],[1.285912,-6.463083,8.747848]],"colors":[[0.8745098,0.3254902,0.4196078,1]],"centers":[[1.935076,-6.123694,7.32965],[1.523273,-5.153558,5.081928],[0.9578652,-5.159118,5.934674],[0.6774811,-3.57888,-3.955973],[0.448786,-3.008945,-5.344293],[-0.4410533,-2.555287,-3.873089],[-0.9134892,-1.305778,-3.958607],[-0.279317,-3.012249,-4.561482],[-1.7883,0.8413665,-5.386076],[-1.456332,-0.07981348,-6.892358],[-0.1910907,-3.253855,-4.764963],[-4.919581,9.986694,-15.26125],[1.396943,-0.2896584,-0.2323906],[-0.4467482,1.249151,-4.403379],[4.418059,-2.65425,-1.424675],[1.702178,-2.572646,-4.48087],[4.356633,-1.263929,1.198248],[-0.2029406,0.3564849,-6.028936],[-0.2663416,-3.386583,5.707243],[-0.6781446,-2.416447,3.459521],[0.4350233,-4.446638,4.660961],[-1.229064,1.944575,0.8309706],[-3.072755,3.483385,-3.340018],[0.9138734,-3.853764,-2.043296],[4.356414,-4.354805,1.908777],[1.867547,-4.694074,1.186088],[6.389881,-5.317025,5.350033],[-1.400319,-0.5454025,-0.1104264],[-0.8631942,-1.912251,1.60602],[-0.007031362,-2.898396,6.797327],[-1.779191,2.058574,7.056231],[-2.775137,1.84444,0.4594028],[-3.59837,4.464426,4.682475],[-0.2046608,-2.830172,-1.960413],[-0.1399722,-2.947511,-0.3294844],[-0.04124403,-3.436195,-3.593992],[0.03120893,-3.534807,-2.349877],[1.798476,4.051797,5.548061],[5.89635,1.44565,6.256643],[3.272908,-0.5128948,8.870964],[1.500748,4.444075,9.129868],[0.06044626,8.675624,10.40924],[-0.3184306,6.849927,6.756112],[-4.205723,7.671398,-9.826757],[-2.767043,3.409242,-9.295379],[-4.267627,6.852874,-5.496953],[-3.160915,3.511898,-3.459293],[-4.332874,8.58488,6.387361],[-4.484958,7.775804,6.115977],[-4.105279,8.200279,6.414203],[1.049571,-4.492456,2.510436],[-4.106081,9.601501,9.769102],[7.991244,-0.9068915,7.074976],[5.892323,-2.241092,9.489231],[4.290959,-6.651226,7.764287]],"normals":[[-0.6703887,-0.5912358,-0.4483517],[-0.6703887,-0.5912358,-0.4483517],[-0.6703887,-0.5912358,-0.4483517],[0.6065667,0.7861269,0.1186657],[0.6065667,0.7861269,0.1186657],[0.6065667,0.7861269,0.1186657],[0.3913291,-0.8166628,-0.4241737],[0.3913291,-0.8166628,-0.4241737],[0.3913291,-0.8166628,-0.4241737],[0.1923881,-0.8805329,-0.4331843],[0.1923881,-0.8805329,-0.4331843],[0.1923881,-0.8805329,-0.4331843],[-0.009998644,0.9447877,0.3275308],[-0.009998644,0.9447877,0.3275308],[-0.009998644,0.9447877,0.3275308],[0.9420292,0.3282681,-0.06943256],[0.9420292,0.3282681,-0.06943256],[0.9420292,0.3282681,-0.06943256],[-0.9305783,-0.3582008,0.07560561],[-0.9305783,-0.3582008,0.07560561],[-0.9305783,-0.3582008,0.07560561],[0.6770532,0.7354061,0.02787436],[0.6770532,0.7354061,0.02787436],[0.6770532,0.7354061,0.02787436],[0.9402941,0.3364672,-0.05135055],[0.9402941,0.3364672,-0.05135055],[0.9402941,0.3364672,-0.05135055],[-0.9307496,-0.3385416,-0.1381839],[-0.9307496,-0.3385416,-0.1381839],[-0.9307496,-0.3385416,-0.1381839],[-0.9715069,-0.004788957,0.2369629],[-0.9715069,-0.004788957,0.2369629],[-0.9715069,-0.004788957,0.2369629],[-0.9865088,-0.162207,0.0221197],[-0.9865088,-0.162207,0.0221197],[-0.9865088,-0.162207,0.0221197],[0.3537781,0.9300517,-0.0992212],[0.3537781,0.9300517,-0.0992212],[0.3537781,0.9300517,-0.0992212],[-0.4176431,-0.7110903,-0.565619],[-0.4176431,-0.7110903,-0.565619],[-0.4176431,-0.7110903,-0.565619],[-0.5914915,0.5346688,0.6035454],[-0.5914915,0.5346688,0.6035454],[-0.5914915,0.5346688,0.6035454],[0.6726562,-0.5097728,-0.5363443],[0.6726562,-0.5097728,-0.5363443],[0.6726562,-0.5097728,-0.5363443],[0.3543168,0.9298546,-0.09914663],[0.3543168,0.9298546,-0.09914663],[0.3543168,0.9298546,-0.09914663],[-0.6319121,-0.3503815,0.6913176],[-0.6319121,-0.3503815,0.6913176],[-0.6319121,-0.3503815,0.6913176],[0.8485901,0.5206991,0.09363401],[0.8485901,0.5206991,0.09363401],[0.8485901,0.5206991,0.09363401],[-0.8063971,-0.5887251,0.05591479],[-0.8063971,-0.5887251,0.05591479],[-0.8063971,-0.5887251,0.05591479],[0.9270095,0.3749525,-0.008003831],[0.9270095,0.3749525,-0.008003831],[0.9270095,0.3749525,-0.008003831],[-0.7290936,-0.6284534,0.2710514],[-0.7290936,-0.6284534,0.2710514],[-0.7290936,-0.6284534,0.2710514],[0.8406412,0.5212298,0.1471117],[0.8406412,0.5212298,0.1471117],[0.8406412,0.5212298,0.1471117],[0.192323,0.9694036,-0.15254],[0.192323,0.9694036,-0.15254],[0.192323,0.9694036,-0.15254],[-0.4634889,0.8457286,0.264426],[-0.4634889,0.8457286,0.264426],[-0.4634889,0.8457286,0.264426],[-0.3801006,-0.8961071,-0.2291626],[-0.3801006,-0.8961071,-0.2291626],[-0.3801006,-0.8961071,-0.2291626],[0.1309049,-0.814817,-0.5647453],[0.1309049,-0.814817,-0.5647453],[0.1309049,-0.814817,-0.5647453],[0.9071485,0.4089177,0.09933783],[0.9071485,0.4089177,0.09933783],[0.9071485,0.4089177,0.09933783],[-0.8635681,-0.4988513,-0.07346618],[-0.8635681,-0.4988513,-0.07346618],[-0.8635681,-0.4988513,-0.07346618],[0.2133253,-0.4082883,-0.8875771],[0.2133253,-0.4082883,-0.8875771],[0.2133253,-0.4082883,-0.8875771],[-0.5737795,-0.4654408,0.6739005],[-0.5737795,-0.4654408,0.6739005],[-0.5737795,-0.4654408,0.6739005],[-0.8565686,-0.504822,-0.1069809],[-0.8565686,-0.504822,-0.1069809],[-0.8565686,-0.504822,-0.1069809],[0.9458802,0.2877937,-0.1499514],[0.9458802,0.2877937,-0.1499514],[0.9458802,0.2877937,-0.1499514],[-0.9421142,-0.3281176,0.06899059],[-0.9421142,-0.3281176,0.06899059],[-0.9421142,-0.3281176,0.06899059],[0.908341,0.4168502,0.03395075],[0.908341,0.4168502,0.03395075],[0.908341,0.4168502,0.03395075],[0.9468806,0.3201424,0.03042726],[0.9468806,0.3201424,0.03042726],[0.9468806,0.3201424,0.03042726],[-0.9205699,-0.3860582,0.05924737],[-0.9205699,-0.3860582,0.05924737],[-0.9205699,-0.3860582,0.05924737],[0.6903765,0.02610283,-0.7229792],[0.6903765,0.02610283,-0.7229792],[0.6903765,0.02610283,-0.7229792],[0.2196872,-0.713926,0.6648663],[0.2196872,-0.713926,0.6648663],[0.2196872,-0.713926,0.6648663],[-0.7282659,0.2298376,0.6456032],[-0.7282659,0.2298376,0.6456032],[-0.7282659,0.2298376,0.6456032],[0.1915031,0.358228,-0.913783],[0.1915031,0.358228,-0.913783],[0.1915031,0.358228,-0.913783],[-0.1852346,-0.2810348,0.9416515],[-0.1852346,-0.2810348,0.9416515],[-0.1852346,-0.2810348,0.9416515],[0.1749238,0.9396015,-0.2941951],[0.1749238,0.9396015,-0.2941951],[0.1749238,0.9396015,-0.2941951],[0.9681032,0.2397568,-0.07275195],[0.9681032,0.2397568,-0.07275195],[0.9681032,0.2397568,-0.07275195],[-0.9321581,-0.3619014,0.01042826],[-0.9321581,-0.3619014,0.01042826],[-0.9321581,-0.3619014,0.01042826],[-0.9202776,-0.3427352,-0.1887375],[-0.9202776,-0.3427352,-0.1887375],[-0.9202776,-0.3427352,-0.1887375],[0.8619561,0.4819905,0.1572158],[0.8619561,0.4819905,0.1572158],[0.8619561,0.4819905,0.1572158],[-0.5889337,0.745699,-0.3115928],[-0.5889337,0.745699,-0.3115928],[-0.5889337,0.745699,-0.3115928],[-0.8487321,-0.4880433,0.2036355],[-0.8487321,-0.4880433,0.2036355],[-0.8487321,-0.4880433,0.2036355],[-0.9834185,0.1809829,0.01154478],[-0.9834185,0.1809829,0.01154478],[-0.9834185,0.1809829,0.01154478],[-0.6746523,-0.7372007,-0.03713956],[-0.6746523,-0.7372007,-0.03713956],[-0.6746523,-0.7372007,-0.03713956],[0.451198,0.206412,-0.8682249],[0.451198,0.206412,-0.8682249],[0.451198,0.206412,-0.8682249],[-0.9923117,-0.07940137,0.09493607],[-0.9923117,-0.07940137,0.09493607],[-0.9923117,-0.07940137,0.09493607],[0.03567316,-0.2104737,0.9769485],[0.03567316,-0.2104737,0.9769485],[0.03567316,-0.2104737,0.9769485],[0.08225221,0.9947416,0.06102201],[0.08225221,0.9947416,0.06102201],[0.08225221,0.9947416,0.06102201]],"ignoreExtent":false,"flags":3},"14":{"id":14,"type":"lines","material":{"lit":false},"vertices":[[1.537181,-5.461595,7.051492],[2.982136,-6.446404,6.18961],[1.537181,-5.461595,7.051492],[1.285912,-6.463083,8.747848],[1.537181,-5.461595,7.051492],[0.05050284,-3.552675,2.004682],[-0.5931032,-2.653636,-6.401013],[2.50443,-4.157528,-1.968361],[-0.5931032,-2.653636,-6.401013],[-0.5864934,-1.811569,-2.33015],[-0.5931032,-2.653636,-6.401013],[-0.1435631,-3.200657,-2.888103],[-0.5931032,-2.653636,-6.401013],[-3.210924,4.629865,-6.612557],[-0.5931032,-2.653636,-6.401013],[0.1211158,-3.925476,-3.498543],[-0.5931032,-2.653636,-6.401013],[-0.1012848,-3.182452,-4.395331],[-0.5931032,-2.653636,-6.401013],[-1.560871,0.5478706,-3.144658],[-0.5931032,-2.653636,-6.401013],[-0.5649692,-2.215669,-7.663503],[-5.3525,11.57575,-22.91605],[-4.525235,7.813531,-13.61007],[-5.3525,11.57575,-22.91605],[-4.881009,10.5708,-9.257639],[3.167072,-1.344741,-3.810746],[-1.296392,0.46233,-2.786833],[3.167072,-1.344741,-3.810746],[2.50443,-4.157528,-1.968361],[3.167072,-1.344741,-3.810746],[2.32015,0.01343586,5.900407],[3.167072,-1.344741,-3.810746],[-3.210924,4.629865,-6.612557],[3.167072,-1.344741,-3.810746],[7.582676,-2.460481,1.505083],[3.167072,-1.344741,-3.810746],[-0.5649692,-2.215669,-7.663503],[-0.03134485,-3.324157,3.230353],[-2.053592,-0.3725095,5.143529],[-0.03134485,-3.324157,3.230353],[1.285912,-6.463083,8.747848],[-0.03134485,-3.324157,3.230353],[0.05050284,-3.552675,2.004682],[-1.296392,0.46233,-2.786833],[2.32015,0.01343586,5.900407],[-1.296392,0.46233,-2.786833],[-3.210924,4.629865,-6.612557],[-1.296392,0.46233,-2.786833],[-4.710948,5.357959,-0.6206625],[2.50443,-4.157528,-1.968361],[0.1211158,-3.925476,-3.498543],[2.50443,-4.157528,-1.968361],[2.982136,-6.446404,6.18961],[2.50443,-4.157528,-1.968361],[7.582676,-2.460481,1.505083],[2.50443,-4.157528,-1.968361],[0.1160741,-3.478288,-0.6629848],[2.50443,-4.157528,-1.968361],[-0.5649692,-2.215669,-7.663503],[8.60483,-7.044188,8.355405],[7.786225,6.783995,11.36444],[8.60483,-7.044188,8.355405],[2.982136,-6.446404,6.18961],[8.60483,-7.044188,8.355405],[1.285912,-6.463083,8.747848],[8.60483,-7.044188,8.355405],[7.582676,-2.460481,1.505083],[-2.053592,-0.3725095,5.143529],[-0.5864934,-1.811569,-2.33015],[-2.053592,-0.3725095,5.143529],[0.7465857,-1.859596,6.500604],[-2.053592,-0.3725095,5.143529],[-4.710948,5.357959,-0.6206625],[-2.053592,-0.3725095,5.143529],[1.285912,-6.463083,8.747848],[-2.053592,-0.3725095,5.143529],[-1.560871,0.5478706,-3.144658],[-2.053592,-0.3725095,5.143529],[0.05050284,-3.552675,2.004682],[-2.053592,-0.3725095,5.143529],[-4.030569,8.407826,9.524559],[-0.5864934,-1.811569,-2.33015],[-0.1435631,-3.200657,-2.888103],[-0.5864934,-1.811569,-2.33015],[-1.560871,0.5478706,-3.144658],[-0.5864934,-1.811569,-2.33015],[0.05050284,-3.552675,2.004682],[-0.5864934,-1.811569,-2.33015],[0.1160741,-3.478288,-0.6629848],[-0.1435631,-3.200657,-2.888103],[0.1211158,-3.925476,-3.498543],[-0.1435631,-3.200657,-2.888103],[-0.1012848,-3.182452,-4.395331],[-0.1435631,-3.200657,-2.888103],[0.1160741,-3.478288,-0.6629848],[7.786225,6.783995,11.36444],[2.32015,0.01343586,5.900407],[7.786225,6.783995,11.36444],[0.7465857,-1.859596,6.500604],[7.786225,6.783995,11.36444],[-3.574318,10.83505,10.33871],[7.786225,6.783995,11.36444],[-4.710948,5.357959,-0.6206625],[7.786225,6.783995,11.36444],[1.285912,-6.463083,8.747848],[7.786225,6.783995,11.36444],[7.582676,-2.460481,1.505083],[7.786225,6.783995,11.36444],[-4.030569,8.407826,9.524559],[2.32015,0.01343586,5.900407],[-4.710948,5.357959,-0.6206625],[2.32015,0.01343586,5.900407],[7.582676,-2.460481,1.505083],[-3.210924,4.629865,-6.612557],[-4.525235,7.813531,-13.61007],[-3.210924,4.629865,-6.612557],[-4.710948,5.357959,-0.6206625],[-3.210924,4.629865,-6.612557],[-4.881009,10.5708,-9.257639],[-3.210924,4.629865,-6.612557],[-1.560871,0.5478706,-3.144658],[-3.210924,4.629865,-6.612557],[-0.5649692,-2.215669,-7.663503],[0.7465857,-1.859596,6.500604],[1.285912,-6.463083,8.747848],[0.7465857,-1.859596,6.500604],[-4.030569,8.407826,9.524559],[0.1211158,-3.925476,-3.498543],[-0.1012848,-3.182452,-4.395331],[0.1211158,-3.925476,-3.498543],[0.1160741,-3.478288,-0.6629848],[-4.713354,9.561626,9.444035],[-3.574318,10.83505,10.33871],[-4.713354,9.561626,9.444035],[-4.710948,5.357959,-0.6206625],[-4.713354,9.561626,9.444035],[-4.030569,8.407826,9.524559],[-4.525235,7.813531,-13.61007],[-4.881009,10.5708,-9.257639],[-4.525235,7.813531,-13.61007],[-0.5649692,-2.215669,-7.663503],[-3.574318,10.83505,10.33871],[-4.710948,5.357959,-0.6206625],[-3.574318,10.83505,10.33871],[-4.030569,8.407826,9.524559],[2.982136,-6.446404,6.18961],[1.285912,-6.463083,8.747848],[2.982136,-6.446404,6.18961],[0.05050284,-3.552675,2.004682],[2.982136,-6.446404,6.18961],[7.582676,-2.460481,1.505083],[2.982136,-6.446404,6.18961],[0.1160741,-3.478288,-0.6629848],[-4.710948,5.357959,-0.6206625],[-4.881009,10.5708,-9.257639],[-4.710948,5.357959,-0.6206625],[-1.560871,0.5478706,-3.144658],[-4.710948,5.357959,-0.6206625],[-4.030569,8.407826,9.524559],[1.285912,-6.463083,8.747848],[0.05050284,-3.552675,2.004682],[0.05050284,-3.552675,2.004682],[0.1160741,-3.478288,-0.6629848]],"colors":[[0.8745098,0.3254902,0.4196078,1]],"centers":[[2.259658,-5.954,6.620551],[1.411546,-5.962338,7.89967],[0.793842,-4.507135,4.528087],[0.9556636,-3.405582,-4.184687],[-0.5897983,-2.232602,-4.365582],[-0.3683331,-2.927146,-4.644558],[-1.902014,0.9881144,-6.506785],[-0.2359937,-3.289556,-4.949779],[-0.347194,-2.918044,-5.398172],[-1.076987,-1.052883,-4.772836],[-0.5790362,-2.434653,-7.032258],[-4.938868,9.694641,-18.26306],[-5.116755,11.07327,-16.08684],[0.9353399,-0.4412054,-3.29879],[2.835751,-2.751135,-2.889553],[2.743611,-0.6656525,1.044831],[-0.02192628,1.642562,-5.211652],[5.374874,-1.902611,-1.152832],[1.301051,-1.780205,-5.737124],[-1.042468,-1.848333,4.186941],[0.6272835,-4.89362,5.9891],[0.009578997,-3.438416,2.617517],[0.5118788,0.2378829,1.556787],[-2.253658,2.546097,-4.699695],[-3.00367,2.910144,-1.703748],[1.312773,-4.041502,-2.733452],[2.743283,-5.301967,2.110625],[5.043553,-3.309005,-0.2316391],[1.310252,-3.817908,-1.315673],[0.9697306,-3.186599,-4.815932],[8.195528,-0.1300967,9.859922],[5.793483,-6.745296,7.272508],[4.945371,-6.753635,8.551626],[8.093753,-4.752335,4.930244],[-1.320043,-1.092039,1.406689],[-0.653503,-1.116053,5.822066],[-3.38227,2.492725,2.261433],[-0.3838399,-3.417796,6.945688],[-1.807231,0.08768055,0.9994355],[-1.001544,-1.962592,3.574106],[-3.04208,4.017658,7.334044],[-0.3650283,-2.506113,-2.609127],[-1.073682,-0.6318491,-2.737404],[-0.2679953,-2.682122,-0.1627342],[-0.2352097,-2.644928,-1.496568],[-0.01122364,-3.563067,-3.193323],[-0.122424,-3.191555,-3.641717],[-0.01374452,-3.339473,-1.775544],[5.053187,3.398715,8.632423],[4.266406,2.462199,8.932522],[2.105954,8.809523,10.85158],[1.537638,6.070977,5.371888],[4.536068,0.1604559,10.05614],[7.684451,2.161757,6.434761],[1.877828,7.595911,10.4445],[-1.195399,2.685697,2.639872],[4.951413,-1.223523,3.702745],[-3.86808,6.221698,-10.11132],[-3.960937,4.993912,-3.61661],[-4.045967,7.600332,-7.935098],[-2.385898,2.588868,-4.878608],[-1.887947,1.207098,-7.13803],[1.016249,-4.161339,7.624226],[-1.641991,3.274115,8.012582],[0.009915505,-3.553964,-3.946937],[0.1185949,-3.701882,-2.080764],[-4.143836,10.19834,9.891373],[-4.712152,7.459793,4.411686],[-4.371962,8.984726,9.484297],[-4.703122,9.192165,-11.43386],[-2.545102,2.798931,-10.63679],[-4.142633,8.096505,4.859025],[-3.802443,9.621439,9.931635],[2.134024,-6.454743,7.468729],[1.516319,-4.99954,4.097146],[5.282406,-4.453443,3.847346],[1.549105,-4.962346,2.763313],[-4.795979,7.964379,-4.939151],[-3.13591,2.952915,-1.88266],[-4.370759,6.882893,4.451948],[0.6682074,-5.007879,5.376265],[0.08328846,-3.515482,0.6708486]],"ignoreExtent":false,"flags":64},"15":{"id":15,"type":"points","material":{"lit":false},"vertices":[[1.537181,-5.461595,7.051492],[-0.5931032,-2.653636,-6.401013],[-5.3525,11.57575,-22.91605],[3.167072,-1.344741,-3.810746],[-0.03134485,-3.324157,3.230353],[-1.296392,0.46233,-2.786833],[2.50443,-4.157528,-1.968361],[8.60483,-7.044188,8.355405],[-2.053592,-0.3725095,5.143529],[-0.5864934,-1.811569,-2.33015],[-0.1435631,-3.200657,-2.888103],[7.786225,6.783995,11.36444],[2.32015,0.01343586,5.900407],[-3.210924,4.629865,-6.612557],[0.7465857,-1.859596,6.500604],[0.1211158,-3.925476,-3.498543],[-4.713354,9.561626,9.444035],[-4.525235,7.813531,-13.61007],[-3.574318,10.83505,10.33871],[2.982136,-6.446404,6.18961],[-4.710948,5.357959,-0.6206625],[-0.1012848,-3.182452,-4.395331],[-4.881009,10.5708,-9.257639],[1.285912,-6.463083,8.747848],[-1.560871,0.5478706,-3.144658],[0.05050284,-3.552675,2.004682],[7.582676,-2.460481,1.505083],[-4.030569,8.407826,9.524559],[0.1160741,-3.478288,-0.6629848],[-0.5649692,-2.215669,-7.663503]],"colors":[[0.8745098,0.3254902,0.4196078,1]],"centers":[[1.537181,-5.461595,7.051492],[-0.5931032,-2.653636,-6.401013],[-5.3525,11.57575,-22.91605],[3.167072,-1.344741,-3.810746],[-0.03134485,-3.324157,3.230353],[-1.296392,0.46233,-2.786833],[2.50443,-4.157528,-1.968361],[8.60483,-7.044188,8.355405],[-2.053592,-0.3725095,5.143529],[-0.5864934,-1.811569,-2.33015],[-0.1435631,-3.200657,-2.888103],[7.786225,6.783995,11.36444],[2.32015,0.01343586,5.900407],[-3.210924,4.629865,-6.612557],[0.7465857,-1.859596,6.500604],[0.1211158,-3.925476,-3.498543],[-4.713354,9.561626,9.444035],[-4.525235,7.813531,-13.61007],[-3.574318,10.83505,10.33871],[2.982136,-6.446404,6.18961],[-4.710948,5.357959,-0.6206625],[-0.1012848,-3.182452,-4.395331],[-4.881009,10.5708,-9.257639],[1.285912,-6.463083,8.747848],[-1.560871,0.5478706,-3.144658],[0.05050284,-3.552675,2.004682],[7.582676,-2.460481,1.505083],[-4.030569,8.407826,9.524559],[0.1160741,-3.478288,-0.6629848],[-0.5649692,-2.215669,-7.663503]],"ignoreExtent":false,"flags":4096},"10":{"id":10,"type":"light","vertices":[[0,0,1]],"colors":[[1,1,1,1],[1,1,1,1],[1,1,1,1]],"viewpoint":true,"finite":false},"9":{"id":9,"type":"background","material":{},"colors":[[0.2980392,0.2980392,0.2980392,1]],"centers":[[0,0,0]],"sphere":false,"fogtype":"none","flags":0},"11":{"id":11,"type":"background","material":{"lit":false,"back":"lines","fog":false},"colors":[[1,1,1,1]],"centers":[[0,0,0]],"sphere":false,"fogtype":"none","flags":0},"12":{"id":12,"type":"background","material":{"lit":false,"back":"lines","fog":false},"colors":[[1,1,1,1]],"centers":[[0,0,0]],"sphere":false,"fogtype":"none","flags":0},"6":{"id":6,"type":"subscene","par3d":{"antialias":1,"FOV":30,"ignoreExtent":false,"listeners":6,"mouseMode":{"left":"trackball","right":"zoom","middle":"fov","wheel":"pull"},"observer":[0,0,80.04165],"modelMatrix":[[1,0,0,-1.626165],[0,0.3420202,0.9396926,4.652538],[0,-0.9396926,0.3420202,-75.93707],[0,0,0,1]],"projMatrix":[[3.732051,0,0,0],[0,3.732051,0,0],[0,0,-3.863704,-288.5409],[0,0,-1,0]],"skipRedraw":false,"userMatrix":[[1,0,0,0],[0,0.3420201,0.9396926,0],[0,-0.9396926,0.3420201,0],[0,0,0,1]],"userProjection":[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]],"scale":[1,1,1],"viewport":{"x":0,"y":0,"width":1,"height":1},"zoom":1,"bbox":[-5.3525,8.60483,-7.044188,11.57575,-22.91605,11.36444],"windowRect":[100,100,388,388],"family":"sans","font":1,"cex":1,"useFreeType":false,"fontname":"NULL","maxClipPlanes":2147483647,"glVersion":2.1,"activeSubscene":0},"embeddings":{"viewport":"replace","projection":"replace","model":"replace","mouse":"replace"},"objects":[12,13,14,15,10],"subscenes":[],"flags":4675}},"width":289,"height":289,"sphereVerts":{"vb":[[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.07465783,0.1464466,0.2126075,0.2705981,0.3181896,0.3535534,0.3753303,0.3826834,0.3753303,0.3535534,0.3181896,0.2705981,0.2126075,0.1464466,0.07465783,0,0,0.1379497,0.2705981,0.3928475,0.5,0.5879378,0.6532815,0.6935199,0.7071068,0.6935199,0.6532815,0.5879378,0.5,0.3928475,0.2705981,0.1379497,0,0,0.18024,0.3535534,0.51328,0.6532815,0.7681778,0.8535534,0.9061274,0.9238795,0.9061274,0.8535534,0.7681778,0.6532815,0.51328,0.3535534,0.18024,0,0,0.1950903,0.3826834,0.5555702,0.7071068,0.8314696,0.9238795,0.9807853,1,0.9807853,0.9238795,0.8314696,0.7071068,0.5555702,0.3826834,0.1950903,0,0,0.18024,0.3535534,0.51328,0.6532815,0.7681778,0.8535534,0.9061274,0.9238795,0.9061274,0.8535534,0.7681778,0.6532815,0.51328,0.3535534,0.18024,0,0,0.1379497,0.2705981,0.3928475,0.5,0.5879378,0.6532815,0.6935199,0.7071068,0.6935199,0.6532815,0.5879378,0.5,0.3928475,0.2705981,0.1379497,0,0,0.07465783,0.1464466,0.2126075,0.2705981,0.3181896,0.3535534,0.3753303,0.3826834,0.3753303,0.3535534,0.3181896,0.2705981,0.2126075,0.1464466,0.07465783,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-0,-0.07465783,-0.1464466,-0.2126075,-0.2705981,-0.3181896,-0.3535534,-0.3753303,-0.3826834,-0.3753303,-0.3535534,-0.3181896,-0.2705981,-0.2126075,-0.1464466,-0.07465783,-0,-0,-0.1379497,-0.2705981,-0.3928475,-0.5,-0.5879378,-0.6532815,-0.6935199,-0.7071068,-0.6935199,-0.6532815,-0.5879378,-0.5,-0.3928475,-0.2705981,-0.1379497,-0,-0,-0.18024,-0.3535534,-0.51328,-0.6532815,-0.7681778,-0.8535534,-0.9061274,-0.9238795,-0.9061274,-0.8535534,-0.7681778,-0.6532815,-0.51328,-0.3535534,-0.18024,-0,-0,-0.1950903,-0.3826834,-0.5555702,-0.7071068,-0.8314696,-0.9238795,-0.9807853,-1,-0.9807853,-0.9238795,-0.8314696,-0.7071068,-0.5555702,-0.3826834,-0.1950903,-0,-0,-0.18024,-0.3535534,-0.51328,-0.6532815,-0.7681778,-0.8535534,-0.9061274,-0.9238795,-0.9061274,-0.8535534,-0.7681778,-0.6532815,-0.51328,-0.3535534,-0.18024,-0,-0,-0.1379497,-0.2705981,-0.3928475,-0.5,-0.5879378,-0.6532815,-0.6935199,-0.7071068,-0.6935199,-0.6532815,-0.5879378,-0.5,-0.3928475,-0.2705981,-0.1379497,-0,-0,-0.07465783,-0.1464466,-0.2126075,-0.2705981,-0.3181896,-0.3535534,-0.3753303,-0.3826834,-0.3753303,-0.3535534,-0.3181896,-0.2705981,-0.2126075,-0.1464466,-0.07465783,-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],[-1,-0.9807853,-0.9238795,-0.8314696,-0.7071068,-0.5555702,-0.3826834,-0.1950903,0,0.1950903,0.3826834,0.5555702,0.7071068,0.8314696,0.9238795,0.9807853,1,-1,-0.9807853,-0.9238795,-0.8314696,-0.7071068,-0.5555702,-0.3826834,-0.1950903,0,0.1950903,0.3826834,0.5555702,0.7071068,0.8314696,0.9238795,0.9807853,1,-1,-0.9807853,-0.9238795,-0.8314696,-0.7071068,-0.5555702,-0.3826834,-0.1950903,0,0.1950903,0.3826834,0.5555702,0.7071068,0.8314696,0.9238795,0.9807853,1,-1,-0.9807853,-0.9238795,-0.8314696,-0.7071068,-0.5555702,-0.3826834,-0.1950903,0,0.1950903,0.3826834,0.5555702,0.7071068,0.8314696,0.9238795,0.9807853,1,-1,-0.9807853,-0.9238795,-0.8314696,-0.7071068,-0.5555702,-0.3826834,-0.1950903,0,0.1950903,0.3826834,0.5555702,0.7071068,0.8314696,0.9238795,0.9807853,1,-1,-0.9807853,-0.9238795,-0.8314696,-0.7071068,-0.5555702,-0.3826834,-0.1950903,0,0.1950903,0.3826834,0.5555702,0.7071068,0.8314696,0.9238795,0.9807853,1,-1,-0.9807853,-0.9238795,-0.8314696,-0.7071068,-0.5555702,-0.3826834,-0.1950903,0,0.1950903,0.3826834,0.5555702,0.7071068,0.8314696,0.9238795,0.9807853,1,-1,-0.9807853,-0.9238795,-0.8314696,-0.7071068,-0.5555702,-0.3826834,-0.1950903,0,0.1950903,0.3826834,0.5555702,0.7071068,0.8314696,0.9238795,0.9807853,1,-1,-0.9807853,-0.9238795,-0.8314696,-0.7071068,-0.5555702,-0.3826834,-0.1950903,0,0.1950903,0.3826834,0.5555702,0.7071068,0.8314696,0.9238795,0.9807853,1,-1,-0.9807853,-0.9238795,-0.8314696,-0.7071068,-0.5555702,-0.3826834,-0.1950903,0,0.1950903,0.3826834,0.5555702,0.7071068,0.8314696,0.9238795,0.9807853,1,-1,-0.9807853,-0.9238795,-0.8314696,-0.7071068,-0.5555702,-0.3826834,-0.1950903,0,0.1950903,0.3826834,0.5555702,0.7071068,0.8314696,0.9238795,0.9807853,1,-1,-0.9807853,-0.9238795,-0.8314696,-0.7071068,-0.5555702,-0.3826834,-0.1950903,0,0.1950903,0.3826834,0.5555702,0.7071068,0.8314696,0.9238795,0.9807853,1,-1,-0.9807853,-0.9238795,-0.8314696,-0.7071068,-0.5555702,-0.3826834,-0.1950903,0,0.1950903,0.3826834,0.5555702,0.7071068,0.8314696,0.9238795,0.9807853,1,-1,-0.9807853,-0.9238795,-0.8314696,-0.7071068,-0.5555702,-0.3826834,-0.1950903,0,0.1950903,0.3826834,0.5555702,0.7071068,0.8314696,0.9238795,0.9807853,1,-1,-0.9807853,-0.9238795,-0.8314696,-0.7071068,-0.5555702,-0.3826834,-0.1950903,0,0.1950903,0.3826834,0.5555702,0.7071068,0.8314696,0.9238795,0.9807853,1,-1,-0.9807853,-0.9238795,-0.8314696,-0.7071068,-0.5555702,-0.3826834,-0.1950903,0,0.1950903,0.3826834,0.5555702,0.7071068,0.8314696,0.9238795,0.9807853,1,-1,-0.9807853,-0.9238795,-0.8314696,-0.7071068,-0.5555702,-0.3826834,-0.1950903,0,0.1950903,0.3826834,0.5555702,0.7071068,0.8314696,0.9238795,0.9807853,1],[0,0.1950903,0.3826834,0.5555702,0.7071068,0.8314696,0.9238795,0.9807853,1,0.9807853,0.9238795,0.8314696,0.7071068,0.5555702,0.3826834,0.1950903,0,0,0.18024,0.3535534,0.51328,0.6532815,0.7681778,0.8535534,0.9061274,0.9238795,0.9061274,0.8535534,0.7681778,0.6532815,0.51328,0.3535534,0.18024,0,0,0.1379497,0.2705981,0.3928475,0.5,0.5879378,0.6532815,0.6935199,0.7071068,0.6935199,0.6532815,0.5879378,0.5,0.3928475,0.2705981,0.1379497,0,0,0.07465783,0.1464466,0.2126075,0.2705981,0.3181896,0.3535534,0.3753303,0.3826834,0.3753303,0.3535534,0.3181896,0.2705981,0.2126075,0.1464466,0.07465783,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,-0,-0.07465783,-0.1464466,-0.2126075,-0.2705981,-0.3181896,-0.3535534,-0.3753303,-0.3826834,-0.3753303,-0.3535534,-0.3181896,-0.2705981,-0.2126075,-0.1464466,-0.07465783,-0,-0,-0.1379497,-0.2705981,-0.3928475,-0.5,-0.5879378,-0.6532815,-0.6935199,-0.7071068,-0.6935199,-0.6532815,-0.5879378,-0.5,-0.3928475,-0.2705981,-0.1379497,-0,-0,-0.18024,-0.3535534,-0.51328,-0.6532815,-0.7681778,-0.8535534,-0.9061274,-0.9238795,-0.9061274,-0.8535534,-0.7681778,-0.6532815,-0.51328,-0.3535534,-0.18024,-0,-0,-0.1950903,-0.3826834,-0.5555702,-0.7071068,-0.8314696,-0.9238795,-0.9807853,-1,-0.9807853,-0.9238795,-0.8314696,-0.7071068,-0.5555702,-0.3826834,-0.1950903,-0,-0,-0.18024,-0.3535534,-0.51328,-0.6532815,-0.7681778,-0.8535534,-0.9061274,-0.9238795,-0.9061274,-0.8535534,-0.7681778,-0.6532815,-0.51328,-0.3535534,-0.18024,-0,-0,-0.1379497,-0.2705981,-0.3928475,-0.5,-0.5879378,-0.6532815,-0.6935199,-0.7071068,-0.6935199,-0.6532815,-0.5879378,-0.5,-0.3928475,-0.2705981,-0.1379497,-0,-0,-0.07465783,-0.1464466,-0.2126075,-0.2705981,-0.3181896,-0.3535534,-0.3753303,-0.3826834,-0.3753303,-0.3535534,-0.3181896,-0.2705981,-0.2126075,-0.1464466,-0.07465783,-0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.07465783,0.1464466,0.2126075,0.2705981,0.3181896,0.3535534,0.3753303,0.3826834,0.3753303,0.3535534,0.3181896,0.2705981,0.2126075,0.1464466,0.07465783,0,0,0.1379497,0.2705981,0.3928475,0.5,0.5879378,0.6532815,0.6935199,0.7071068,0.6935199,0.6532815,0.5879378,0.5,0.3928475,0.2705981,0.1379497,0,0,0.18024,0.3535534,0.51328,0.6532815,0.7681778,0.8535534,0.9061274,0.9238795,0.9061274,0.8535534,0.7681778,0.6532815,0.51328,0.3535534,0.18024,0,0,0.1950903,0.3826834,0.5555702,0.7071068,0.8314696,0.9238795,0.9807853,1,0.9807853,0.9238795,0.8314696,0.7071068,0.5555702,0.3826834,0.1950903,0]],"it":[[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270],[17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,34,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,51,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,68,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,85,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,102,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,119,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,136,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,153,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,170,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,187,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,204,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,221,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,238,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,255,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,272,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288],[18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271,273,274,275,276,277,278,279,280,281,282,283,284,285,286,287,288,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,18,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,35,36,37,38,39,40,41,42,43,44,45,46,47,48,49,50,52,53,54,55,56,57,58,59,60,61,62,63,64,65,66,67,69,70,71,72,73,74,75,76,77,78,79,80,81,82,83,84,86,87,88,89,90,91,92,93,94,95,96,97,98,99,100,101,103,104,105,106,107,108,109,110,111,112,113,114,115,116,117,118,120,121,122,123,124,125,126,127,128,129,130,131,132,133,134,135,137,138,139,140,141,142,143,144,145,146,147,148,149,150,151,152,154,155,156,157,158,159,160,161,162,163,164,165,166,167,168,169,171,172,173,174,175,176,177,178,179,180,181,182,183,184,185,186,188,189,190,191,192,193,194,195,196,197,198,199,200,201,202,203,205,206,207,208,209,210,211,212,213,214,215,216,217,218,219,220,222,223,224,225,226,227,228,229,230,231,232,233,234,235,236,237,239,240,241,242,243,244,245,246,247,248,249,250,251,252,253,254,256,257,258,259,260,261,262,263,264,265,266,267,268,269,270,271]],"material":[],"normals":null,"texcoords":[[0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0.0625,0.0625,0.0625,0.0625,0.0625,0.0625,0.0625,0.0625,0.0625,0.0625,0.0625,0.0625,0.0625,0.0625,0.0625,0.0625,0.0625,0.125,0.125,0.125,0.125,0.125,0.125,0.125,0.125,0.125,0.125,0.125,0.125,0.125,0.125,0.125,0.125,0.125,0.1875,0.1875,0.1875,0.1875,0.1875,0.1875,0.1875,0.1875,0.1875,0.1875,0.1875,0.1875,0.1875,0.1875,0.1875,0.1875,0.1875,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.25,0.3125,0.3125,0.3125,0.3125,0.3125,0.3125,0.3125,0.3125,0.3125,0.3125,0.3125,0.3125,0.3125,0.3125,0.3125,0.3125,0.3125,0.375,0.375,0.375,0.375,0.375,0.375,0.375,0.375,0.375,0.375,0.375,0.375,0.375,0.375,0.375,0.375,0.375,0.4375,0.4375,0.4375,0.4375,0.4375,0.4375,0.4375,0.4375,0.4375,0.4375,0.4375,0.4375,0.4375,0.4375,0.4375,0.4375,0.4375,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5,0.5625,0.5625,0.5625,0.5625,0.5625,0.5625,0.5625,0.5625,0.5625,0.5625,0.5625,0.5625,0.5625,0.5625,0.5625,0.5625,0.5625,0.625,0.625,0.625,0.625,0.625,0.625,0.625,0.625,0.625,0.625,0.625,0.625,0.625,0.625,0.625,0.625,0.625,0.6875,0.6875,0.6875,0.6875,0.6875,0.6875,0.6875,0.6875,0.6875,0.6875,0.6875,0.6875,0.6875,0.6875,0.6875,0.6875,0.6875,0.75,0.75,0.75,0.75,0.75,0.75,0.75,0.75,0.75,0.75,0.75,0.75,0.75,0.75,0.75,0.75,0.75,0.8125,0.8125,0.8125,0.8125,0.8125,0.8125,0.8125,0.8125,0.8125,0.8125,0.8125,0.8125,0.8125,0.8125,0.8125,0.8125,0.8125,0.875,0.875,0.875,0.875,0.875,0.875,0.875,0.875,0.875,0.875,0.875,0.875,0.875,0.875,0.875,0.875,0.875,0.9375,0.9375,0.9375,0.9375,0.9375,0.9375,0.9375,0.9375,0.9375,0.9375,0.9375,0.9375,0.9375,0.9375,0.9375,0.9375,0.9375,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1],[0,0.0625,0.125,0.1875,0.25,0.3125,0.375,0.4375,0.5,0.5625,0.625,0.6875,0.75,0.8125,0.875,0.9375,1,0,0.0625,0.125,0.1875,0.25,0.3125,0.375,0.4375,0.5,0.5625,0.625,0.6875,0.75,0.8125,0.875,0.9375,1,0,0.0625,0.125,0.1875,0.25,0.3125,0.375,0.4375,0.5,0.5625,0.625,0.6875,0.75,0.8125,0.875,0.9375,1,0,0.0625,0.125,0.1875,0.25,0.3125,0.375,0.4375,0.5,0.5625,0.625,0.6875,0.75,0.8125,0.875,0.9375,1,0,0.0625,0.125,0.1875,0.25,0.3125,0.375,0.4375,0.5,0.5625,0.625,0.6875,0.75,0.8125,0.875,0.9375,1,0,0.0625,0.125,0.1875,0.25,0.3125,0.375,0.4375,0.5,0.5625,0.625,0.6875,0.75,0.8125,0.875,0.9375,1,0,0.0625,0.125,0.1875,0.25,0.3125,0.375,0.4375,0.5,0.5625,0.625,0.6875,0.75,0.8125,0.875,0.9375,1,0,0.0625,0.125,0.1875,0.25,0.3125,0.375,0.4375,0.5,0.5625,0.625,0.6875,0.75,0.8125,0.875,0.9375,1,0,0.0625,0.125,0.1875,0.25,0.3125,0.375,0.4375,0.5,0.5625,0.625,0.6875,0.75,0.8125,0.875,0.9375,1,0,0.0625,0.125,0.1875,0.25,0.3125,0.375,0.4375,0.5,0.5625,0.625,0.6875,0.75,0.8125,0.875,0.9375,1,0,0.0625,0.125,0.1875,0.25,0.3125,0.375,0.4375,0.5,0.5625,0.625,0.6875,0.75,0.8125,0.875,0.9375,1,0,0.0625,0.125,0.1875,0.25,0.3125,0.375,0.4375,0.5,0.5625,0.625,0.6875,0.75,0.8125,0.875,0.9375,1,0,0.0625,0.125,0.1875,0.25,0.3125,0.375,0.4375,0.5,0.5625,0.625,0.6875,0.75,0.8125,0.875,0.9375,1,0,0.0625,0.125,0.1875,0.25,0.3125,0.375,0.4375,0.5,0.5625,0.625,0.6875,0.75,0.8125,0.875,0.9375,1,0,0.0625,0.125,0.1875,0.25,0.3125,0.375,0.4375,0.5,0.5625,0.625,0.6875,0.75,0.8125,0.875,0.9375,1,0,0.0625,0.125,0.1875,0.25,0.3125,0.375,0.4375,0.5,0.5625,0.625,0.6875,0.75,0.8125,0.875,0.9375,1,0,0.0625,0.125,0.1875,0.25,0.3125,0.375,0.4375,0.5,0.5625,0.625,0.6875,0.75,0.8125,0.875,0.9375,1]],"meshColor":"vertices"},"context":{"shiny":false,"rmarkdown":"rmarkdown::html_vignette"},"crosstalk":{"key":[],"group":[],"id":[],"options":[]}});
webshot__is_phantomjs_installed__rgl.prefix = "webshot__is_phantomjs_installed__";
</script>
<p id="webshot__is_phantomjs_installed__debug">
You must enable Javascript to view this page properly.
</p>
<script>webshot__is_phantomjs_installed__rgl.start();</script>
</div>
<div id="colour-volume-overlap-with-alpha-shapes" class="section level1">
<h1>Colour volume overlap with <span class="math inline">\(\alpha\)</span>-shapes</h1>
<p><span class="math inline">\(\alpha\)</span>-shapes can also be used to measure the colour similarity of two objects, by computing the colour volume overlap. This is done in <code>pavo</code> with the <code>overlap3d()</code> function. For example, let’s compare the colour volume of the crown and the breast of stripe-tailed yellow finches (<em>Sicalis citrina</em>):</p>
<div class="sourceCode" id="cb8"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb8-1"><a href="#cb8-1"></a><span class="kw">data</span>(sicalis)</span>
<span id="cb8-2"><a href="#cb8-2"></a>tcs.sicalis.C &lt;-<span class="st"> </span><span class="kw">subset</span>(<span class="kw">colspace</span>(<span class="kw">vismodel</span>(sicalis)), <span class="st">&quot;C&quot;</span>)</span>
<span id="cb8-3"><a href="#cb8-3"></a>tcs.sicalis.B &lt;-<span class="st"> </span><span class="kw">subset</span>(<span class="kw">colspace</span>(<span class="kw">vismodel</span>(sicalis)), <span class="st">&quot;B&quot;</span>)</span></code></pre></div>
<div class="sourceCode" id="cb9"><pre class="sourceCode r"><code class="sourceCode r"><span id="cb9-1"><a href="#cb9-1"></a><span class="kw">voloverlap</span>(tcs.sicalis.C, tcs.sicalis.B, <span class="dt">type =</span> <span class="st">&quot;alpha&quot;</span>, <span class="dt">plot =</span> <span class="ot">TRUE</span>)</span>
<span id="cb9-2"><a href="#cb9-2"></a><span class="co">#&gt; &#39;avalue&#39; automatically set to 2.4445e-02</span></span>
<span id="cb9-3"><a href="#cb9-3"></a><span class="co">#&gt; &#39;avalue&#39; automatically set to 2.6255e-01</span></span>
<span id="cb9-4"><a href="#cb9-4"></a><span class="co">#&gt; Warning in overlap3d(colsp1, colsp2, avalue, plot, interactive, col, fill, :</span></span>
<span id="cb9-5"><a href="#cb9-5"></a><span class="co">#&gt; interactive = FALSE has not been implemented yet, falling back to interactive</span></span>
<span id="cb9-6"><a href="#cb9-6"></a><span class="co">#&gt; plot.</span></span>
<span id="cb9-7"><a href="#cb9-7"></a><span class="co">#&gt; Warning in f(...): partial argument match of &#39;col&#39; to &#39;color&#39;</span></span>
<span id="cb9-8"><a href="#cb9-8"></a></span>
<span id="cb9-9"><a href="#cb9-9"></a><span class="co">#&gt; Warning in f(...): partial argument match of &#39;col&#39; to &#39;color&#39;</span></span>
<span id="cb9-10"><a href="#cb9-10"></a><span class="co">#&gt;           vol1         vol2 s_in1 s_in2 s_inboth s_ineither psmallest pboth</span></span>
<span id="cb9-11"><a href="#cb9-11"></a><span class="co">#&gt; 1 1.849436e-06 4.586381e-06     3     8        0         11         0     0</span></span></code></pre></div>
<div id="unnamed_chunk_13div" class="rglWebGL">

</div>
<script type="text/javascript">
var unnamed_chunk_13div = document.getElementById("unnamed_chunk_13div"),
unnamed_chunk_13rgl = new rglwidgetClass();
unnamed_chunk_13div.width = 289;
unnamed_chunk_13div.height = 289;
unnamed_chunk_13rgl.initialize(unnamed_chunk_13div,
{"material":{"color":"#000000","alpha":1,"lit":true,"ambient":"#000000","specular":"#FFFFFF","emission":"#000000","shininess":50,"smooth":true,"front":"filled","back":"filled","size":3,"lwd":1,"fog":false,"point_antialias":false,"line_antialias":false,"texture":null,"textype":"rgb","texmipmap":false,"texminfilter":"linear","texmagfilter":"linear","texenvmap":false,"depth_mask":true,"depth_test":"less","isTransparent":false,"polygon_offset":[0,0]},"rootSubscene":17,"objects":{"23":{"id":23,"type":"triangles","material":{"front":"lines","back":"lines"},"vertices":[[0.277018,0.09431786,-0.1515835],[0.2761168,0.1001045,-0.1487953],[0.2906266,0.1097732,-0.1875149],[0.277018,0.09431786,-0.1515835],[0.2943043,0.09960984,-0.1946033],[0.2906266,0.1097732,-0.1875149],[0.277018,0.09431786,-0.1515835],[0.2906266,0.1097732,-0.1875149],[0.2563524,0.09850378,-0.1886372],[0.2943043,0.09960984,-0.1946033],[0.2906266,0.1097732,-0.1875149],[0.2563524,0.09850378,-0.1886372],[0.2943043,0.09960984,-0.1946033],[0.2906266,0.1097732,-0.1875149],[0.2942916,0.1019892,-0.1944124],[0.277018,0.09431786,-0.1515835],[0.2761168,0.1001045,-0.1487953],[0.2563524,0.09850378,-0.1886372],[0.2923992,0.1031932,-0.1981311],[0.2943043,0.09960984,-0.1946033],[0.2563524,0.09850378,-0.1886372],[0.2923992,0.1031932,-0.1981311],[0.2943043,0.09960984,-0.1946033],[0.2942916,0.1019892,-0.1944124],[0.2923992,0.1031932,-0.1981311],[0.2906266,0.1097732,-0.1875149],[0.2563524,0.09850378,-0.1886372],[0.2923992,0.1031932,-0.1981311],[0.2906266,0.1097732,-0.1875149],[0.2942916,0.1019892,-0.1944124],[0.2761168,0.1001045,-0.1487953],[0.2906266,0.1097732,-0.1875149],[0.2563524,0.09850378,-0.1886372]],"colors":[[0,0,1,1]],"centers":[[0.2812538,0.1013985,-0.1626312],[0.2873163,0.1012336,-0.1779006],[0.2746657,0.1008649,-0.1759119],[0.2804278,0.1026289,-0.1902518],[0.2930741,0.1037907,-0.1921769],[0.2698291,0.09764205,-0.1630053],[0.2810186,0.1004356,-0.1937906],[0.293665,0.1015974,-0.1957156],[0.2797927,0.1038234,-0.1914277],[0.2924391,0.1049852,-0.1933528],[0.2743653,0.1027938,-0.1749825]],"normals":[[-0.9379016,0.02078464,-0.346278],[-0.9379016,0.02078464,-0.346278],[-0.9379016,0.02078464,-0.346278],[0.9226782,0.06935062,0.3792827],[0.9226782,0.06935062,0.3792827],[0.9226782,0.06935062,0.3792827],[-0.3084288,0.9106618,0.2748942],[-0.3084288,0.9106618,0.2748942],[-0.3084288,0.9106618,0.2748942],[0.1467716,-0.5295834,0.8354636],[0.1467716,-0.5295834,0.8354636],[0.1467716,-0.5295834,0.8354636],[-0.8653749,0.0354867,-0.499867],[-0.8653749,0.0354867,-0.499867],[-0.8653749,0.0354867,-0.499867],[-0.8378705,-0.3372901,0.429195],[-0.8378705,-0.3372901,0.429195],[-0.8378705,-0.3372901,0.429195],[-0.08686927,-0.7219796,-0.6864396],[-0.08686927,-0.7219796,-0.6864396],[-0.08686927,-0.7219796,-0.6864396],[-0.8957319,-0.04032309,0.4427621],[-0.8957319,-0.04032309,0.4427621],[-0.8957319,-0.04032309,0.4427621],[0.2468953,-0.8046655,0.5399593],[0.2468953,-0.8046655,0.5399593],[0.2468953,-0.8046655,0.5399593],[0.7931175,0.5680763,-0.2196676],[0.7931175,0.5680763,-0.2196676],[0.7931175,0.5680763,-0.2196676],[-0.3136556,0.9422087,0.1177407],[-0.3136556,0.9422087,0.1177407],[-0.3136556,0.9422087,0.1177407]],"ignoreExtent":false,"flags":3},"24":{"id":24,"type":"triangles","material":{"front":"lines","back":"lines"},"vertices":[[0.2587177,0.1105616,-0.1245272],[0.2723658,0.1129477,-0.148945],[0.2203372,0.09899914,-0.09086048],[0.2195961,0.1026547,-0.0977259],[0.2723658,0.1129477,-0.148945],[0.2203372,0.09899914,-0.09086048],[0.2195961,0.1026547,-0.0977259],[0.2723658,0.1129477,-0.148945],[0.1605064,0.07712152,-0.06163791],[0.2411471,0.1069592,-0.1086814],[0.2195961,0.1026547,-0.0977259],[0.2203372,0.09899914,-0.09086048],[0.2411471,0.1069592,-0.1086814],[0.2195961,0.1026547,-0.0977259],[0.2404047,0.1145845,-0.1312312],[0.2587177,0.1105616,-0.1245272],[0.2411471,0.1069592,-0.1086814],[0.2203372,0.09899914,-0.09086048],[0.2587177,0.1105616,-0.1245272],[0.2411471,0.1069592,-0.1086814],[0.2404047,0.1145845,-0.1312312],[0.2195961,0.1026547,-0.0977259],[0.1605064,0.07712152,-0.06163791],[0.2404047,0.1145845,-0.1312312],[0.2195961,0.1026547,-0.0977259],[0.2203372,0.09899914,-0.09086048],[0.1605064,0.07712152,-0.06163791],[0.2587177,0.1105616,-0.1245272],[0.2723658,0.1129477,-0.148945],[0.2404047,0.1145845,-0.1312312],[0.2723658,0.1129477,-0.148945],[0.1605064,0.07712152,-0.06163791],[0.2404047,0.1145845,-0.1312312]],"colors":[[1,0,0,1]],"centers":[[0.2504736,0.1075028,-0.1214442],[0.237433,0.1048672,-0.1125105],[0.2174895,0.09757464,-0.1027696],[0.2270268,0.102871,-0.09908926],[0.233716,0.1080661,-0.1125462],[0.2400673,0.1055066,-0.108023],[0.2467565,0.1107018,-0.12148],[0.2068357,0.09812024,-0.09686502],[0.2001466,0.09292512,-0.0834081],[0.2571627,0.1126979,-0.1349012],[0.2244256,0.1015513,-0.113938]],"normals":[[-0.3863441,0.9136158,-0.1266663],[-0.3863441,0.9136158,-0.1266663],[-0.3863441,0.9136158,-0.1266663],[-0.2519872,-0.8652107,-0.4334894],[-0.2519872,-0.8652107,-0.4334894],[-0.2519872,-0.8652107,-0.4334894],[-0.571705,0.6851739,-0.4513203],[-0.571705,0.6851739,-0.4513203],[-0.571705,0.6851739,-0.4513203],[0.05943342,0.8837603,0.4641499],[0.05943342,0.8837603,0.4641499],[0.05943342,0.8837603,0.4641499],[0.02591664,-0.9467267,-0.3209938],[0.02591664,-0.9467267,-0.3209938],[0.02591664,-0.9467267,-0.3209938],[0.6788486,-0.1822786,0.7112939],[0.6788486,-0.1822786,0.7112939],[0.6788486,-0.1822786,0.7112939],[-0.0916419,-0.9442297,-0.3162785],[-0.0916419,-0.9442297,-0.3162785],[-0.0916419,-0.9442297,-0.3162785],[0.3239546,-0.9367692,-0.1323514],[0.3239546,-0.9367692,-0.1323514],[0.3239546,-0.9367692,-0.1323514],[0.0877991,-0.8753026,-0.4755384],[0.0877991,-0.8753026,-0.4755384],[0.0877991,-0.8753026,-0.4755384],[0.1485043,0.9727486,0.1780634],[0.1485043,0.9727486,0.1780634],[0.1485043,0.9727486,0.1780634],[-0.4471942,-0.4652926,-0.7638849],[-0.4471942,-0.4652926,-0.7638849],[-0.4471942,-0.4652926,-0.7638849]],"ignoreExtent":false,"flags":3},"25":{"id":25,"type":"spheres","material":{"lit":false},"vertices":[[0.2870993,0.1074852,-0.182419],[0.2860177,0.1065552,-0.1813837],[0.285824,0.1058255,-0.1783888]],"colors":[[0,0,1,1]],"radii":[[0.001]],"centers":[[0.2870993,0.1074852,-0.182419],[0.2860177,0.1065552,-0.1813837],[0.285824,0.1058255,-0.1783888]],"ignoreExtent":false,"flags":2},"26":{"id":26,"type":"spheres","material":{"lit":false},"vertices":[[0.2139595,0.1010287,-0.103789],[0.2392891,0.1094184,-0.1262806],[0.2326089,0.1071232,-0.1159621],[0.2105886,0.09698296,-0.1000146],[0.2528343,0.1088832,-0.1341247],[0.2449309,0.1092015,-0.1171317],[0.2303249,0.1063867,-0.120025],[0.2493178,0.112849,-0.1350531]],"colors":[[1,0,0,1]],"radii":[[0.001]],"centers":[[0.2139595,0.1010287,-0.103789],[0.2392891,0.1094184,-0.1262806],[0.2326089,0.1071232,-0.1159621],[0.2105886,0.09698296,-0.1000146],[0.2528343,0.1088832,-0.1341247],[0.2449309,0.1092015,-0.1171317],[0.2303249,0.1063867,-0.120025],[0.2493178,0.112849,-0.1350531]],"ignoreExtent":false,"flags":2},"21":{"id":21,"type":"light","vertices":[[0,0,1]],"colors":[[1,1,1,1],[1,1,1,1],[1,1,1,1]],"viewpoint":true,"finite":false},"20":{"id":20,"type":"background","material":{"fog":true},"colors":[[0.2980392,0.2980392,0.2980392,1]],"centers":[[0,0,0]],"sphere":false,"fogtype":"none","flags":0},"22":{"id":22,"type":"background","material":{"lit":false,"back":"lines"},"colors":[[1,1,1,1]],"centers":[[0,0,0]],"sphere":false,"fogtype":"none","flags":0},"17":{"id":17,"type":"subscene","par3d":{"antialias":1,"FOV":1,"ignoreExtent":false,"listeners":17,"mouseMode":{"left":"zAxis","right":"xAxis","middle":"zoom","wheel":"none"},"observer":[0,0,11.1597],"modelMatrix":[[1,0,0,-0.2274053],[0,0.3420202,0.9396926,0.08926786],[0,-0.9396926,0.3420202,-11.0252],[0,0,0,1]],"projMatrix":[[114.5886,0,0,0],[0,114.5886,0,0],[0,0,-114.5931,-1278.728],[0,0,-1,0]],"skipRedraw":false,"userMatrix":[[1,0,0,0],[0,0.3420201,0.9396926,0],[0,-0.9396926,0.3420201,0],[0,0,0,1]],"userProjection":[[1,0,0,0],[0,1,0,0],[0,0,1,0],[0,0,0,1]],"scale":[1,1,1],"viewport":{"x":0,"y":0,"width":1,"height":1},"zoom":1,"bbox":[0.1605064,0.2943043,0.07712152,0.1145845,-0.1981311,-0.06163791],"windowRect":[100,100,388,388],"family":"sans","font":1,"cex":1,"useFreeType":false,"fontname":"NULL","maxClipPlanes":2147483647,"glVersion":2.1,"activeSubscene":0},"embeddings":{"viewport":"replace","projection":"replace","model":"replace","mouse":"replace"},"objects":[22,23,24,25,26,21],"subscenes":[],"flags":515}},"width":289,"height":289,"sphereVerts":{"reuse":"webshot__is_phantomjs_installed__div"},"context":{"shiny":false,"rmarkdown":"rmarkdown::html_vignette"},"crosstalk":{"key":[],"group":[],"id":[],"options":[]}});
unnamed_chunk_13rgl.prefix = "unnamed_chunk_13";
</script>
<p id="unnamed_chunk_13debug">
You must enable Javascript to view this page properly.
</p>
<script>unnamed_chunk_13rgl.start();</script>
<!-- # Exploring other values of $\alpha$ -->
<!-- Depending on your biological question, it is possible you might want a different -->
<!-- value of $\alpha$ than the $\alpha^*$ suggested earlier.  -->
<!-- For example, you may want all your colour volumes to only have one component, -->
<!-- instead of several multiple smaller volumes. Here is a quick demo of how you can -->
<!-- do this. -->
<!-- First, let's create a dummy dataset with two distinct clouds of points: -->
<!-- ```{r} -->
<!-- set.seed("20200126") -->
<!-- dvol = data.frame( -->
<!--   "x" = c(rnorm(n = 10, mean = -0.7/sqrt(2)+.3, sd = 0.05), -->
<!--           rnorm(n = 10, mean =  0.7/sqrt(2)-.3, sd = 0.05)), -->
<!--   "y" = c(rnorm(n = 10, mean = -0.25*sqrt(2/3)+.3, sd = 0.05), -->
<!--           rnorm(n = 10, mean = -0.25*sqrt(2/3)+.3  , sd = 0.05)), -->
<!--   "z" = c(rnorm(n = 10, mean = -0.5*sqrt(2/3)+.3, sd = 0.05), -->
<!--           rnorm(n = 10, mean = -0.5*sqrt(2/3)+.3  , sd = 0.05)) -->
<!-- ) -->
<!-- ``` -->
<!-- With the approach highlighted before, this will result in a colour volume with -->
<!-- two distinct components: -->
<!-- ```{r} -->
<!-- tetraplot(dvol) -->
<!-- vol(dvol, type= "alpha") -->
<!-- ``` -->
<!-- To prevent this, we can add an additional test with the following code: -->
<!-- ```{r} -->
<!-- library(alphashape3d) -->
<!-- tetras <- ashape3d(as.matrix(dvol), alpha = 0)$tetra -->
<!-- tetras <- tetras[order(tetras[, "rhoT"]), ] -->
<!-- i <- 0 -->
<!-- all_in <- FALSE -->
<!-- while (!all_in && i < nrow(tetras)) { -->
<!--   i <- i+1 -->
<!--   points_in <- unique(c(tetras[seq_len(i), 1:4])) -->
<!--   all_in <- all(seq_len(nrow(dvol)) %in% points_in) -->
<!-- } -->
<!-- a_1 <- tetras[i, "rhoT"] -->
<!-- ``` -->
<!-- ```{r} -->
<!-- tetraplot(dvol) -->
<!-- vol(dvol, type= "alpha", avalue = tetras[i+20, "rhoT"]) -->
<!-- ``` -->
<div id="refs" class="references hanging-indent">
<div id="ref-Gruson2020">
<p>Gruson, Hugo. 2020. “Estimation of Colour Volumes as Concave Hypervolumes Using α-Shapes.” <em>Methods in Ecology and Evolution</em> 11 (8): 955–63. <a href="https://doi.org/10.1111/2041-210X.13398">https://doi.org/10.1111/2041-210X.13398</a>.</p>
</div>
<div id="ref-Stoddard2008">
<p>Stoddard, Mary Caswell, and Richard O. Prum. 2008. “Evolution of Avian Plumage Color in a Tetrahedral Color Space: A Phylogenetic Analysis of New World Buntings.” <em>The American Naturalist</em> 171 (6): 755–76. <a href="https://doi.org/10.1086/587526">https://doi.org/10.1086/587526</a>.</p>
</div>
</div>
</div>



<!-- code folding -->


<!-- dynamically load mathjax for compatibility with self-contained -->
<script>
  (function () {
    var script = document.createElement("script");
    script.type = "text/javascript";
    script.src  = "https://mathjax.rstudio.com/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML";
    document.getElementsByTagName("head")[0].appendChild(script);
  })();
</script>

</body>
</html>
